# 데이터베이스 설계

## 데이터베이스 설계의 중요성

데이터베이스는 백엔드 개발에서 기반이 되는 매우 중요한 부분이다. 자바나 파이썬 같은 애플리케이션 코드는 프레임워크나 아키텍처 패턴 덕분에 기능 추가나 코드 리팩토링을 유연하게 처리할 수 있다. 하지만 데이터베이스 구조(스키마)는 바로 잡는데 많은 비용 및 시간이 필요하다. 그렇기 때문에 데이터베이스의 설계 기반을 제대로 잡아야 한다.  

<br/>

잘못된 데이터베이스 설계는 데이터 무결성을 훼손하여 데이터 중복 및 삽입, 수정, 삭제 이상현상을 일으킨다. 그리고 정규화되지 않은 데이터는 하나의 테이블에 많은 데이터가 모두 모여있어 성능을 저하시키고 유지보수의 비용을 증가시킨다.  

또한 개발 단계로 넘어간 후 설계를 수정하려면 이미 들어간 데이터들 및 수정이 매우 힘들어진다. 만약 애플리케이션을 배포 후 데이터베이스를 수정한다고 하면 이러한 문제는 더 커질 것이다. 이처럼 데이터베이스를 초반에 설계하는 것은 미래에 발생할 재앙을 막고 시스템의 수명을 늘리는 현명한 투자가 될 것이다.  

<br/>
<br/>

## 데이터베이스 설계의 3단계 - 개념, 논리, 물리

데이터베이스 설계의 각 단계를 자세히 확인하기 전에 요약해서 확인한다

- 개념적 설계는 비즈니스 요구 사항을 이해가고, 현실 세계에서 물리적으로 존재하거나 논리적인 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계이다. 이 단계에서는 NoSQL, RDBMS 등에 종속되지 않으며 비즈니스 전문가와 고객의 요구 사항을 분석하여 산출물인 ERD 같은 설계도를 만들어낸다.  
- 논리적 설계는 개념적 설계에서 만든 밑그림을, 사용하려는 관계형 데이터베이스의 원리에 맞게 구체적인 구조로 다듬는 단계다. 이 때 실제 사용하는 RDBMS를 산정하지 않기 때문에 종속되지는 않는다. 이 단계에서 데이터는 어떤 타입으로 할 것인지(숫자, 문자, 날짜 등)와 테이블의 정규화를 적용하고 속성, PK, FK 등을 명확하게 정의한다.  
- 물리적 설계는 논리적 설계에서 만든 테이블 스키마를 실제 사용할 RDBMS에 맞게 최적화하여 구현하는 단계이다. 실제 사용될 테이블의 컬럼의 데이터 타입을 정하고, 어떤 인덱스를 사용하면 좋을지 결정한다. 그리고 DDL을 통해 물리적인 테이블을 생성한다.  

<br/>
<br/>
<br/>

# 개념적 모델링 - 개념

데이터베이스 설계는 개념적 모델링부터 시작한다. 우리가 데이터베이스의 테이블을 바로 생성하지 않는것은 데이터베이스가 결국 '현실 세계의 비즈니스'를 반영하는 거울이기 때문에다. 개념적 모델링은 개발자, 기획자, 현업 담당자 등이 모여 기술적인 용어 대신에 모두가 이해할 수 있는 그림과 용어로 만들어야 할 것을 명확하게 하는 가장 중요한 단계이다.  

모델 설계는 요구 사항 분석에서 시작되며, 요구 사항을 분석해서 데이터 세상의 뼈대를 생성할 때 '명사'와 '동사'에 집중해야 하며, **명사**는 우리가 관리해야할 대상인 엔티티나 엔티티가 가지는 속성이 될 확률이 높으며, **동사**는 관계가 될 확률이 높다.  

<br/>
<br/>

## 엔티티 도출하기

개념적 모델링의 가장 기본적인 요소는 '엔티티(Entity)'다. 엔티티는 저장할 가치가 잇는 중요한 데이터를 가지며, 다른 것들과 식별될 수 있는 대상이다.  
여기서 명사가 엔티티가 된다고 했지만, '문법적인 명사' 만이 아니라 동사이어도 시스템이 정보를 저장하고 관리해야 할 대상은 엔티티가 될 수 있다.

'쇼핑몰 요구 사항'에서 우리는 '회원', '주문', '상품' 이라는 엔티티를 도출했으며, 이 엔티티 서로서로가 관계가 있음을 확인할 수 있다.  
- '회원'과 '주문' 사이에 관계가 있다. (누가 주문했는가?)
- '주문'과 '상품' 사이에 관계가 있다. (무엇을 주문했는가?)

<br/>
<br/>

## 엔티티란?

엔티티는 "우리가 데이터를 저장하고 관리해야 할 대상"으로, 구체적으로 "저장할만할 가치가 있는 정보를 여러 개 가지고 있으면서, 다른것과 명확이 구분되는 유무형의 모든 것"을 말한다.  

- **유형 엔티티**는 사람, 사물, 장소와 같이 물리적인 형태가 있는, 우리가 직접 만지거나 볼 수 있는 대상을 의미하며 회원, 직원, 상품, 책 등이 있다.  
- **무형 엔티티**는 물리적인 형태는 없지만, 개념적으로 존재하는 관리 대상을 의미하고 주로 어떤 '사건'이나 '개념'을 데이터로 관리할 때
나타내며 주문, 예약, 수강 신청, 계좌 등이 있다.  

### 엔티티의 특징

- 엔티티는 반드시 해당 업무에 필요하고 관리해야 하는 정보이고, 업무 프로세스에 의해 이용되어야 한다.
- 엔티티에 속하는 각각의 데이터는 서로 명확하게 구분할 수 있아여 한다. 회원의 아이디를 부여하는 것과 같으며, 이것이 나중에 '식별자(Identifier)' 또는 '기본 키(Primary Key)'가 된다.  
- 엔티티는 관리할 만할 가치가 있는 여러 정보인 속성(컬럼)들을 가진다. 단일 속성을 가진다면 엔티티가 아닌 다른 엔티티의 일부 속성일 것이다.
- 엔티티는 개념적인 틀이며, 틀에 만들어진 실제 데이터 하나하나를 인스턴스라고 한다. 엔티티는 이 인스턴스들의 집합니다. 
- 엔티티는 다른 엔티티와 서로 관계를 맺는다. 엔티티들의 관계를 파악하는 것이 데이터베이스 설계의 핵심이다.  

<br/>
<br/>

## 엔티티 분류1

데이터베이스 설계는 '회원', '상품', '주문'과 같은 데이터를 식별하는 것에서 시작하며, 이 데이터들은 성격이 다르므로 회원은 잘 변하지 않는 데이터지만, 주문은 매 순간 새롭게 쌓이며 폭발적으로 증가할 수 있다.  

이처럼 엔티티의 성격과 역할을 제대로 파악하고 구분하는 과정이 엔티티 분류다. 엔티티를 분류하는 주요 기준은 존재 형태, 생성 시점 및 역할, 존재 종속성(독립성)이다.

<br/>

### 존재 형태에 따른 분류: 유형, 개념, 사건 엔티티

엔티티를 식별하는 가장 직관적인 방법 중 하나는 엔티티가 나타내는 대상의 존재 형태를 기준으로 분류하는 것이다. 크게 유형 엔티티, 개념 엔티티, 사건 엔티티로 구분할 수 있다.

<br/> 

1\. 유형 엔티티  
물리적인 실체를 가지는 엔티티다. 이들은 현실 세계에 구체적으로 존재하므로 데이터 모델링에서 가장 먼저 식별되는 경향이 있다. 유형 엔티티는 상대적으로 안정적이며 지속적으로 활용되는 정보를 담는다. 예로는 사원, 학생, 고객, 상품, 차량 등이 있다.  

<br/> 

2\. 개념 엔티티  
물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티다. 눈으로 보이지 않기 때문에 유형 엔티티에 비해 식별하기가 다소 까다롭고, 비즈니스 프로세스에 대한 깊은 이해가 필요하다. 업무 규칙이나 제도, 분류 기준 등을 표현하며, 유형엔티티와 마찬가지로 비교적 안정적인 정보를 관리한다. 예로는 부서, 조직, 팀, 계좌, 과목, 학과 등이 있다.

<br/> 

3\. 사건 엔티티(이벤트 엔티티)  
업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티다. 특정 시점에 발생하며, 비즈니스 활동 결과를 기록하는 역할을 한다. 즉, 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 소스가 된다. 예로는 주문, 계약, 청구, 매출, 결제, 입금, 출금, 수강신청, 예약, 사고접수 등이 있다.

<br/> 

데이터 모델에 '주문', '결제', '예약' 같은 사건 엔티티가 가득하다면, 그 시스템은 매일매일의 거래를 기록하는 온라인 거래 장부와 같을 것이고, '고객', '상품', '직원' 같은 유형/개념 엔티티가 설계의 중심이라면, 여러 곳에서 상용될 기준 정보나 고객 명단을 관리하는 시스템일 가능성이 높다.

데이터의 성격과 증가 추이를 미리 파악하면 '주문' 같은 테이블을 설계할 때 인덱스를 미리 설계하거나, 데이터 파티셔닝 및 아카이빙을 미리 준비할 수 있다.  

<br/>
<br/>

### 역할 및 발생 시점에 따른 분류: 기본, 중심, 행위 엔티티

엔티티는 비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있다. 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화 한다.

<br/>

1\. 기본 엔티티(Fundamental/Key Entity)  
업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티다. '키 엔티티'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행하고, 다른 엔티티의 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가진다. 예로는 회원, 상품, 사원, 부서, 고객 등이 있다.  

<br/> 

2\. 중심 엔티티(Main/Center Entity)  
기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티다. 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많다. 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 한다. 예로는 주문, 계약, 청구, 매출 등이 있다.  

<br/> 

3\. 행위 엔티티(Action/Behavioral Entity)  
두 개 이상의 부모 엔티티(주로 기본 엔티티와 중심 엔티티)로부터 발생하며, 업무가 흘러가면서 생성되는 상세 정보를 기록하는 엔티티다. 내용이 자주 변경되거나 데이터양이 지속적으로 증가하는 특징을 가지며, 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많다. 예로는 주문 이력, 변경이력, 로그 등이 있다.  

<br/>

이 세 가지 분류는 '기본->중심->행위'로 업무가 흘러가는 순서와 데이터의 원인과 결과를 명확하게 보여준다.

<br/>

실무에서 중요한 것은 분류 용어들을 외우기보다는 본질을 이해하는 것이 중요하다. 
이 분류법은 **사고의 틀**을 제공하는 것이고, 용어 자체를 암기해서 사용하는 것이 목적이 아니라, 각 테이블이 가지는 데이터의 '본질'과 '성격'을 빠르고 정확하게 간파하는 훈련을 하는 것이다.

<br/>
<br/>

## 엔티티 분류2

### 강한 엔티티와 약한 엔티티

엔티티는 다른 엔티티와의 관계 속에서 자신의 존재 여부가 결정되는지에 따라 강한 엔티티와 약한 엔티티로 분류할 수 있다.  

1\. 강한 엔티티(Strong Entity)  
다른 어떤 엔티티의 존재 여부와 관계없이 독립적으로 존재할 수 있는 엔티티를 의미하며, 다른 엔티티에 의존하지 않는다. 자신을 유일하게 식별할 수 잇는 속성들의 집합인 기본 키를 가진다. 예로는 사원, 고객, 상품, 부서 등과 같은 독립적으로 관리되는 대부분의 엔티티가 있다.  

<br/>

2\. 약한 엔티티(Weak Entity)  
다른 엔티티('소유 엔티티' 또는 '식별 엔티티'로 부르는 강한 엔티티)가 존재하지 않으면 독립적으로 존재할 수 없는 존재 종속적인 엔티티다. 전통적인 방식에서 약한 엔티티는 소유 엔티티의 주식별자를 빌려와 자신의 속성과 결합하여 주식별자를 삼아 자신을 식별한다. 예로는 부양가족 등이 있다.

<br/>

강한 엔티티와 약한 엔티티를 구분하면, 예를 들어 부모 엔티티(사원) 정보가 없는 자식 데이터(부양가족), 즉 고아 데이터가 생겨나면 데이터베이스 정합성이 깨지고, 시스템이 신뢰를 잃게 된다. 이 때 약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장하며, 부모가 존재하지 않는 문제를 설계 단계에서 원천 차단할 수 있다.  
강한 엔티티와 약한 엔티티의 구분은 바로 이런 데이터 재앙을 **설계 단계에서부터 원천적으로 차단**하기 위해 존재한다.  

하지만 이런 정통방식을 최에는 잘 사용하지 않고, 더 유연하고 실용적인 비 식별 관계라는 방법을 주로 사용한다.

<br/>
<br/>

### 구조적 관계 표현을 위한 특수 엔티티

엔티티 간의 관계가 단순한 연결선을 넘어, 그 자체가 하나의 독립된 의미를 갖는 개념일 때가 있는데, 이러한 사건(Event)이나 분류(Classification)와 같은 복잡한 관계를 효과적으로 모델에 반영하기 위해 사용하는 것이 연관 엔티티와 슈퍼타입/서브타입 구조이다.  

<br/>

1\. 연관 엔티티(Associative Entity)  
두 개 이상의 엔티티 간에 발생하는 특정 사건, 행위 계약 등을 표현하기 위해 도출되는 엔티티이다. 즉, 관계 자체가 중요한 속성을 가져 하나의 독립된 실체(Entity)로 다뤄져야 할 때 사용된다.
연관 엔티티의 가장 중요한 존재 이유는 '관계'에 종속되는 속성을 저장하기 위함으로, 예를 들어 '학생'과 '과목'의 관계에서는 '성적'이나 '수강신청일' 같은 데이터가 발생하는데 이 데이터는 학생이나 과목의 것이 아닌 수강이라는 행위 차제에 속하는데, 이 수강을 표현한느 것이 연관 엔티티로, 연관 엔티티는 두 개 이상의 다른 엔티티 간에 존재하는 다대다(M:N) 관계를 해소한다.  

<br/>

2\. 슈퍼타입/서브타입 엔티티(Supertype/Subtype Entity)  
논리적으로 동일한 개념 그룹에 속하지만 일부 속성이나 관계에서 차이가 있는 엔티티들을 효과적으로 표현하기 위한 기법이다. 'Is - a' 관계를 모델링하며, 객체지향 프로그래밍의 상속 개념과 유사하다.  

<br/>
<br/>

## 엔티티의 세부 정보, 속성 정의

속성(Attribute)이란 엔티티가 가지는 구체적인 특성이나 정보다. '회원'이라는 엔티티가 있을 때 속성은 회원명, 이메일, 전화번호, 주소가 된다.  

식별자는 정의된 속성들 중에서 아주 특별한 역할을 하는 속성으로 엔티티의 인스턴스(row)를 다른 데이터와 유일하게 구별해주는 이름표 역할을 한다. 데이터베이스의 기본 키가 된다.

<br/>
<br/>

## 카디널리티와 참여도

카디널리티와 참여도는 관계의 규칙을 정의하는 두 가지 핵심 요소이다.  

<br/>

### 관계의 수량, 카디널리티 분석

카디널리티는 한 엔티티의 인스턴스(row)가 다른 엔티티의 인스턴스와 몇 개나 관계를 맺을 수 있는지를 나타내는 수량 제약이다. 1:1, 1:N, 1:M, M:N 관계를 따지는 것이다.  

카디널리티는 엔티티 인스턴스(row) 하나가 다른 엔티티의 인스턴스와 맺을 수 있는 최대 숫자를 기준으로 표기한다.  
- 1(하나): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 최대 1개의 관계를 가질 수 있을 때 사용한다.
- N(하나 이상): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 1개 이상, 즉 여러 개의 관계를 가질 수 있을 때 사용한다.  

<br/>

### 관계의 필수 여부, 참여도 분석

참여도는 한 엔티티의 인스턴스가 관계에 반드시 참여해야 하는지(필수), 아니면 참여하지 않을 수도 있는지(선택)를 결정한다.  

 개념적 모델링 단계는 RDBMS를 포함한 특정 기술에 종속되지 않기 때문에 외래키는 표함되지 않으며 엔티티간의 관계는 관계선으로 표한한다.  

<br/>
<br/>

## ERD

엔티티, 속성, 식별자, 관계, 카디널리티, 참여도를 하나의 그림으로 표현한 것이 ERD(Entity-Relationship Diagram)다.  

ERD를 그리는 방법은 '피터 챈 표기법'과 '까마귀발 표기법'이 있는데 주로 까마귀발 표기법이 사용된다. 까마귀발 표기법이 정보 밀도와 가독성이 좋고 표현이 직관적이다. 그리고 Dbeaver, ERDCloud 등 많은 데이터베이스 도구가 까마귀발 표기법을 기본으로 지원한다.  

<br/>
<br/>

## 다대다(M:N) 관계 해결

다대다 관계는 물리적으로 구현될 수 없으며, 관계에 속한 데이터를 저장할 장소가 없다. 이 문제를 해결하기 위해서는 다대다 관계를 연관 엔티티로 바꾸어 해결해야 한다.  

<br/>
<br/>

## 용어 사전

프로젝트의 모든 이해 관계자들은 같은 비즈니스 용어를 사용하는 것이 중요하다.  
개념적, 논리적 모델링 단계에서는 비즈니스 담당자들과 원활한 소통을 위해 한글 용어를 사용하는 경우가 많으며, 물리적 모델링 단계에서는 이 한글 용어들을 정한 규칙에 따라 영어로 정확하게 변환해야 하는데 이 때 **용어 사전**을 만들어 관리하면 편리하다.  

용어 사전은 많은 개발자들과 협업에서 서로 다른 변수명, 함수명, 테이블명 등의 용어를 사용할 때 공통으로 사용되는 용어를 정리해서 혼란없이 진행할 수 있는 '프로젝트 용어의 헌법'과 같다.  

단순히 단어를 나열하는 것을 넘어, 실무에서는 보다 체계적이고 상세한 용어 사전을 사용하며, 용어를 역할별로 분류하고, 약어와 전체 영문명을 명확히 구분하며, 실제 시스템에서 어떻게 사용되는지 구체적인 예시를 함꼐 기록하는 것이 좋다.  

용어 사전은 프로젝트가 진행됨에 따라 지속적으로 업데이트해서 최신 상태를 유지하고, 팀원 모두가 쉽게 접근 및 편집할 수 있는 도구를 사용해서 관리해야 한다.  

<br/>
<br/>

# 개념적 모델링 - 실전

프로젝트를 시작하고 요구 사항읋 분석해서 설계를 시작할 때 시작부터 전체 기능을 준비하고 기간을 잡으면 시작부터 삐걱거릴 수 있다.  

기능을 설계할 때는 필수적인 핵심 기능 및 지금 당장 필요한 기능부터 설계를 시작하면 개발 기간을 단축시키고, 이후에 차근차근 필요한 기능을 추가하면서 서비스를 오픈하는 것이 좋다. 

노련하고 숙련된 개발자와 기획자는 프로젝트를 잘개 쪼개서 지금 당장 필요하거나 필요하지 않은 것들을 분리할 줄 알아야 한다.

<br/>
<br/>

## 개념적 모델링 - 설계 시작

### 1단계: 핵심 요구 사항 다시 정의하기 (MVP)

핵심 요구 사항을 다시 정의하는 이 과정을 MVP(Minimum Viable Product, 최소 기능 제품) 라고 한다.  

복잡한 기능인 외부 판매자 기능, 쿠폰, 리뷰, 장바구니 기능같은 2차 기능은 미루고 1차 기능(핵심 기능)을 위주로 구현하고 나중에 2차 기능을 추가 개발한다.  

**쇼핑몰 MVP 기능 명세서**  
- 회원: 고객이 가입하고 자신의 정보를 관리할 수 있어야 한다.
- 상품: 우리가 판매할 상품을 등록하고 관리할 수 있어야 한다.
- 주문: 회원이 상품을 구매할 수 있어야 한다.
- 결제: 주문에 대한 결제 정보를 기록하고 관리할 수 있어야 한다.
- 배송: '결제가 완료된' 주문의 배송 상태를 관리할 수 있어야 한다.

<br/>

### 2단계: 핵심 엔티티 도출

핵심 기능을 추려서 단순해진 요구 사항에서 엔티티를 찾는다.   

도출된 핵심 엔티티: `회원` , `상품` , `주문` , `결제` , `배송`

<br/>

### 3단계: 속성 정의 및 관계 설정

- `회원(Member)`: 회원id, 로그인id, 비밀번호, 회원명, 이메일, 주소
- `상품(Product)`: 상품id, 상품명, 상품 가격, 재고 수량
- `주문(Order)`: 주문id, 주문 상태, 배송지 주소, 주문 일시
- `결제(Payment)`: 결제id, 결제 수단, 결제 금액, 결제 상태, 결제 일시
- `배송(Delivery)`: 배송id, 배송 상태, 운송장 번호  

<br/>

엔티티 관계 확인
- 회원은 여러 번 주문할 수 있다.(1:N)
- 하나의 주문에 대해서 하나의 결제가 이루어진다.(1:1)
- 하나의 주문에 대해서 하나의 배송이 이루어진다.(1:1)
- 하나의 주문에는 여러 상품이 포함될 수 있고, 하나의 상품은 여러 주문에 포함될 수 있다.(M:N)  

<br/>

### 4단계: M:N관계 해소와 '연관 엔티티'

M:N 관계는 물리적으로 구현할 수 없기 때문에 연관 엔티티를 도입해야 한다. 우리는 '주문' 엔티티와 '상품' 엔티티 사이에 '주문 항목'이라는 연관 엔티티를 도입한다.  

## 개념적 모델링 - ERD 작성

ERD 설계도를 만들기 위한 툴은 `draw.io`를 사용한다.  

![shopping mall erd](/Database/images/01-erd.png)

개념적 모델링의 목표는 모든 속성을 나타내는 것이 아닌 기획, 개발 등 모든 사람들의 이해를 돕는 것이 목표로, 핵심적인 것을 나타내고 등록일, 수정일과 같은 거의 모든 엔티티에 들어가는 속성은 생략했다.

개념점 모델링에서는 특정 데이터베이스에 종속되지 않기 때문에 외래키를 표현하지 않았지만, 실무에서는 보통 관계형 데이터베이스를 사용하기 때문에 개념적 모델링과 논리적 모델링을 함께 처리하는 경우 외래키를 표시하기도 하며, 보통 개발자 이외의 기획자들도 외래키가 있다고 해서 이해를 어렵게하지는 않는다.  

<br/>
<br/>
<br/>

# 논리적 모델링

논리적 모델링은 개념적 모델링에서 만든 청사진을 관계형 데이터베이스 구조에 맞게 변호나하는 과정이다. 엔티티는 **테이블**로, 속성은 **컬럼**으로 바꾸고, 각 테이블의 **기본 키(Primary Key)** 와 테이블 간의 관계를 표현하는 **외래 키(Foreign Key)** 등을 정의한다.

<br/>

## 키의 중요성

논리적 모델링은 특정 RDBMS에 종속되지 않는 순수한 데이터 구조를 설꼐하며, 가장 중요하게 다루어야 할 것이 '키(Key)'다.  

키는 데이터베이스 테이블의 각 행(Row)을 유일하게 식별할 수 있는 장치다. 키는 데이터를 찾는 용도 뿐만 아니라 테이블과 테이블을 연결해 관계를 맺어주고, 데이터 중복 및 잘못 입력되는 것을 막는 무결성 제약조건의 역할도 수행한다.  

<br/>

### 키(Key)

키는 테이블에 있는 각각의 행을 고유하게 식별할 수 잇는 하나 이상의 컬럼 집합이다.

#### **기본키(Primary Key - PK)**  
- 테이블의 모든 행을 유일하게 식별하는 대표 키다.
  - NULL 값을 가질 수 없다.(NOT NULL)
  - 반드시 유일해야 한다.(UNIQUE)
  - 값이 변하지 않아야 한다.(불변성)

#### **후보키(Candidate Key)**
- 기본 키가 될 수 있는 후보들을 말하며, 유일성과 최소성을 모두 만족하는 키를 말한다. 
  - 유일성(Unique): 모든 행을 서로 구분할 수 있어야 한다.
  - 최소성(Minimality): 행을 유일하게 식별하는 데 꼭 필요한 최소한의 컬럼만 포함해야 한다.

#### **대체 키(Alternate Key)**
- 후보 키 중에서 기본 키로 선택되지 않은 나머지 키들을 말한다.
- 회원 테이블에서 `member_id`가 기본 키로 선택됐다면, 유니크한 값으로 설정된 `email`, `phone`과 같은 속성은 대체 키가 된다.  

#### **외래 키(Foreign Key - FK)
- 테이블간의 관계를 연결하는 역할을 하는 중요한 키다.
- 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하는 것이다.