# 데이터베이스 설계

## 데이터베이스 설계의 중요성

데이터베이스는 백엔드 개발에서 기반이 되는 매우 중요한 부분이다. 자바나 파이썬 같은 애플리케이션 코드는 프레임워크나 아키텍처 패턴 덕분에 기능 추가나 코드 리팩토링을 유연하게 처리할 수 있다. 하지만 데이터베이스 구조(스키마)는 바로 잡는데 많은 비용 및 시간이 필요하다. 그렇기 때문에 데이터베이스의 설계 기반을 제대로 잡아야 한다.  

<br/>

잘못된 데이터베이스 설계는 데이터 무결성을 훼손하여 데이터 중복 및 삽입, 수정, 삭제 이상현상을 일으킨다. 그리고 정규화되지 않은 데이터는 하나의 테이블에 많은 데이터가 모두 모여있어 성능을 저하시키고 유지보수의 비용을 증가시킨다.  

또한 개발 단계로 넘어간 후 설계를 수정하려면 이미 들어간 데이터들 및 수정이 매우 힘들어진다. 만약 애플리케이션을 배포 후 데이터베이스를 수정한다고 하면 이러한 문제는 더 커질 것이다. 이처럼 데이터베이스를 초반에 설계하는 것은 미래에 발생할 재앙을 막고 시스템의 수명을 늘리는 현명한 투자가 될 것이다.  

<br/>
<br/>

## 데이터베이스 설계의 3단계 - 개념, 논리, 물리

데이터베이스 설계의 각 단계를 자세히 확인하기 전에 요약해서 확인한다

- 개념적 설계는 비즈니스 요구 사항을 이해가고, 현실 세계에서 물리적으로 존재하거나 논리적인 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계이다. 이 단계에서는 NoSQL, RDBMS 등에 종속되지 않으며 비즈니스 전문가와 고객의 요구 사항을 분석하여 산출물인 ERD 같은 설계도를 만들어낸다.  
- 논리적 설계는 개념적 설계에서 만든 밑그림을, 사용하려는 관계형 데이터베이스의 원리에 맞게 구체적인 구조로 다듬는 단계다. 이 때 실제 사용하는 RDBMS를 산정하지 않기 때문에 종속되지는 않는다. 이 단계에서 데이터는 어떤 타입으로 할 것인지(숫자, 문자, 날짜 등)와 테이블의 정규화를 적용하고 속성, PK, FK 등을 명확하게 정의한다.  
- 물리적 설계는 논리적 설계에서 만든 테이블 스키마를 실제 사용할 RDBMS에 맞게 최적화하여 구현하는 단계이다. 실제 사용될 테이블의 컬럼의 데이터 타입을 정하고, 어떤 인덱스를 사용하면 좋을지 결정한다. 그리고 DDL을 통해 물리적인 테이블을 생성한다.  

<br/>
<br/>
<br/>

# 개념적 모델링 - 개념

데이터베이스 설계는 개념적 모델링부터 시작한다. 우리가 데이터베이스의 테이블을 바로 생성하지 않는것은 데이터베이스가 결국 '현실 세계의 비즈니스'를 반영하는 거울이기 때문에다. 개념적 모델링은 개발자, 기획자, 현업 담당자 등이 모여 기술적인 용어 대신에 모두가 이해할 수 있는 그림과 용어로 만들어야 할 것을 명확하게 하는 가장 중요한 단계이다.  

모델 설계는 요구 사항 분석에서 시작되며, 요구 사항을 분석해서 데이터 세상의 뼈대를 생성할 때 '명사'와 '동사'에 집중해야 하며, **명사**는 우리가 관리해야할 대상인 엔티티나 엔티티가 가지는 속성이 될 확률이 높으며, **동사**는 관계가 될 확률이 높다.  

<br/>
<br/>

## 엔티티 도출하기

개념적 모델링의 가장 기본적인 요소는 '엔티티(Entity)'다. 엔티티는 저장할 가치가 잇는 중요한 데이터를 가지며, 다른 것들과 식별될 수 있는 대상이다.  
여기서 명사가 엔티티가 된다고 했지만, '문법적인 명사' 만이 아니라 동사이어도 시스템이 정보를 저장하고 관리해야 할 대상은 엔티티가 될 수 있다.

'쇼핑몰 요구 사항'에서 우리는 '회원', '주문', '상품' 이라는 엔티티를 도출했으며, 이 엔티티 서로서로가 관계가 있음을 확인할 수 있다.  
- '회원'과 '주문' 사이에 관계가 있다. (누가 주문했는가?)
- '주문'과 '상품' 사이에 관계가 있다. (무엇을 주문했는가?)

<br/>
<br/>

## 엔티티란?

엔티티는 "우리가 데이터를 저장하고 관리해야 할 대상"으로, 구체적으로 "저장할만할 가치가 있는 정보를 여러 개 가지고 있으면서, 다른것과 명확이 구분되는 유무형의 모든 것"을 말한다.  

- **유형 엔티티**는 사람, 사물, 장소와 같이 물리적인 형태가 있는, 우리가 직접 만지거나 볼 수 있는 대상을 의미하며 회원, 직원, 상품, 책 등이 있다.  
- **무형 엔티티**는 물리적인 형태는 없지만, 개념적으로 존재하는 관리 대상을 의미하고 주로 어떤 '사건'이나 '개념'을 데이터로 관리할 때
나타내며 주문, 예약, 수강 신청, 계좌 등이 있다.  

### 엔티티의 특징

- 엔티티는 반드시 해당 업무에 필요하고 관리해야 하는 정보이고, 업무 프로세스에 의해 이용되어야 한다.
- 엔티티에 속하는 각각의 데이터는 서로 명확하게 구분할 수 있아여 한다. 회원의 아이디를 부여하는 것과 같으며, 이것이 나중에 '식별자(Identifier)' 또는 '기본 키(Primary Key)'가 된다.  
- 엔티티는 관리할 만할 가치가 있는 여러 정보인 속성(컬럼)들을 가진다. 단일 속성을 가진다면 엔티티가 아닌 다른 엔티티의 일부 속성일 것이다.
- 엔티티는 개념적인 틀이며, 틀에 만들어진 실제 데이터 하나하나를 인스턴스라고 한다. 엔티티는 이 인스턴스들의 집합니다. 
- 엔티티는 다른 엔티티와 서로 관계를 맺는다. 엔티티들의 관계를 파악하는 것이 데이터베이스 설계의 핵심이다.  

<br/>
<br/>

## 엔티티 분류1

데이터베이스 설계는 '회원', '상품', '주문'과 같은 데이터를 식별하는 것에서 시작하며, 이 데이터들은 성격이 다르므로 회원은 잘 변하지 않는 데이터지만, 주문은 매 순간 새롭게 쌓이며 폭발적으로 증가할 수 있다.  

이처럼 엔티티의 성격과 역할을 제대로 파악하고 구분하는 과정이 엔티티 분류다. 엔티티를 분류하는 주요 기준은 존재 형태, 생성 시점 및 역할, 존재 종속성(독립성)이다.

<br/>

### 존재 형태에 따른 분류: 유형, 개념, 사건 엔티티

엔티티를 식별하는 가장 직관적인 방법 중 하나는 엔티티가 나타내는 대상의 존재 형태를 기준으로 분류하는 것이다. 크게 유형 엔티티, 개념 엔티티, 사건 엔티티로 구분할 수 있다.

<br/> 

1\. 유형 엔티티  
물리적인 실체를 가지는 엔티티다. 이들은 현실 세계에 구체적으로 존재하므로 데이터 모델링에서 가장 먼저 식별되는 경향이 있다. 유형 엔티티는 상대적으로 안정적이며 지속적으로 활용되는 정보를 담는다. 예로는 사원, 학생, 고객, 상품, 차량 등이 있다.  

<br/> 

2\. 개념 엔티티  
물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티다. 눈으로 보이지 않기 때문에 유형 엔티티에 비해 식별하기가 다소 까다롭고, 비즈니스 프로세스에 대한 깊은 이해가 필요하다. 업무 규칙이나 제도, 분류 기준 등을 표현하며, 유형엔티티와 마찬가지로 비교적 안정적인 정보를 관리한다. 예로는 부서, 조직, 팀, 계좌, 과목, 학과 등이 있다.

<br/> 

3\. 사건 엔티티(이벤트 엔티티)  
업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티다. 특정 시점에 발생하며, 비즈니스 활동 결과를 기록하는 역할을 한다. 즉, 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 소스가 된다. 예로는 주문, 계약, 청구, 매출, 결제, 입금, 출금, 수강신청, 예약, 사고접수 등이 있다.

<br/> 

데이터 모델에 '주문', '결제', '예약' 같은 사건 엔티티가 가득하다면, 그 시스템은 매일매일의 거래를 기록하는 온라인 거래 장부와 같을 것이고, '고객', '상품', '직원' 같은 유형/개념 엔티티가 설계의 중심이라면, 여러 곳에서 상용될 기준 정보나 고객 명단을 관리하는 시스템일 가능성이 높다.

데이터의 성격과 증가 추이를 미리 파악하면 '주문' 같은 테이블을 설계할 때 인덱스를 미리 설계하거나, 데이터 파티셔닝 및 아카이빙을 미리 준비할 수 있다.  

<br/>
<br/>

### 역할 및 발생 시점에 따른 분류: 기본, 중심, 행위 엔티티

엔티티는 비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있다. 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화 한다.

<br/>

1\. 기본 엔티티(Fundamental/Key Entity)  
업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티다. '키 엔티티'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행하고, 다른 엔티티의 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가진다. 예로는 회원, 상품, 사원, 부서, 고객 등이 있다.  

<br/> 

2\. 중심 엔티티(Main/Center Entity)  
기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티다. 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많다. 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 한다. 예로는 주문, 계약, 청구, 매출 등이 있다.  

<br/> 

3\. 행위 엔티티(Action/Behavioral Entity)  
두 개 이상의 부모 엔티티(주로 기본 엔티티와 중심 엔티티)로부터 발생하며, 업무가 흘러가면서 생성되는 상세정보를 기록하는 엔티티다. 내용이 자주 변경되거나 데이터양이 지속적으로 증가하는 특징을 가지며, 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많다. 예로는 주문 이력, 변경이력, 로그 등이 있다.  

<br/>

이 세 가지 분류는 '기본->중심->행위'로 업무가 흘러가는 순서와 데이터의 원인과 결과를 명확하게 보여준다.

<br/>

실무에서 중요한 것은 분류 용어들을 외우기보다는 본질을 이해하는 것이 중요하다. 
이 분류법은 **사고의 틀**을 제공하는 것이고, 용어 자체를 암기해서 사용하는 것이 목적이 아니라, 각 테이블이 가지는 데이터의 '본질'과 '성격'을 빠르고 정확하게 간파하는 훈련을 하는 것이다.

<br/>
<br/>

## 엔티티 분류2

### 강한 엔티티와 약한 엔티티

엔티티는 다른 엔티티와의 관계 속에서 자신의 존재 여부가 결정되는지에 따라 강한 엔티티와 약한 엔티티로 분류할 수 있다.  

1\. 강한 엔티티(Strong Entity)  
다른 어떤 엔티티의 존재 여부와 관계없이 독립적으로 존재할 수 있는 엔티티를 의미하며, 다른 엔티티에 의존하지 않는다. 자신을 유일하게 식별할 수 잇는 속성들의 집합인 기본 키를 가진다. 예로는 사원, 고객, 상품, 부서 등과 같은 독립적으로 관리되는 대부분의 엔티티가 있다.  

<br/>

2\. 약한 엔티티(Weak Entity)  
다른 엔티티('소유 엔티티' 또는 '식별 엔티티'로 부르는 강한 엔티티)가 존재하지 않으면 독립적으로 존재할 수 없는 존재 종속적인 엔티티다. 전통적인 방식에서 약한 엔티티는 소유 엔티티의 주식별자를 빌려와 자신의 속성과 결합하여 주식별자를 삼아 자신을 식별한다. 예로는 부양가족 등이 있다.

<br/>

강한 엔티티와 약한 엔티티를 구분하면, 예를 들어 부모 엔티티(사원) 정보가 없는 자식 데이터(부양가족), 즉 고아 데이터가 생겨나면 데이터베이스 정합성이 깨지고, 시스템이 신뢰를 잃게 된다. 이 때 약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장하며, 부모가 존재하지 않는 문제를 설계 단계에서 원천 차단할 수 있다.  
강한 엔티티와 약한 엔티티의 구분은 바로 이런 데이터 재앙을 **설계 단계에서부터 원천적으로 차단**하기 위해 존재한다.  

하지만 이런 정통방식을 최에는 잘 사용하지 않고, 더 유연하고 실용적인 비 식별 관계라는 방법을 주로 사용한다.

<br/>
<br/>

### 구조적 관계 표현을 위한 특수 엔티티

엔티티 간의 관계가 단순한 연결선을 넘어, 그 자체가 하나의 독립된 의미를 갖는 개념일 때가 있는데, 이러한 사건(Event)이나 분류(Classification)와 같은 복잡한 관계를 효과적으로 모델에 반영하기 위해 사용하는 것이 연관 엔티티와 슈퍼타입/서브타입 구조이다.  

<br/>

1\. 연관 엔티티(Associative Entity)  
두 개 이상의 엔티티 간에 발생하는 특정 사건, 행위 계약 등을 표현하기 위해 도출되는 엔티티이다. 즉, 관계 자체가 중요한 속성을 가져 하나의 독립된 실체(Entity)로 다뤄져야 할 때 사용된다.
연관 엔티티의 가장 중요한 존재 이유는 '관계'에 종속되는 속성을 저장하기 위함으로, 예를 들어 '학생'과 '과목'의 관계에서는 '성적'이나 '수강신청일' 같은 데이터가 발생하는데 이 데이터는 학생이나 과목의 것이 아닌 수강이라는 행위 차제에 속하는데, 이 수강을 표현한느 것이 연관 엔티티로, 연관 엔티티는 두 개 이상의 다른 엔티티 간에 존재하는 다대다(M:N) 관계를 해소한다.  

<br/>

2\. 슈퍼타입/서브타입 엔티티(Supertype/Subtype Entity)  
논리적으로 동일한 개념 그룹에 속하지만 일부 속성이나 관계에서 차이가 있는 엔티티들을 효과적으로 표현하기 위한 기법이다. 'Is - a' 관계를 모델링하며, 객체지향 프로그래밍의 상속 개념과 유사하다.  

<br/>
<br/>

## 엔티티의 세부 정보, 속성 정의

속성(Attribute)이란 엔티티가 가지는 구체적인 특성이나 정보다. '회원'이라는 엔티티가 있을 때 속성은 회원명, 이메일, 전화번호, 주소가 된다.  

식별자는 정의된 속성들 중에서 아주 특별한 역할을 하는 속성으로 엔티티의 인스턴스(row)를 다른 데이터와 유일하게 구별해주는 이름표 역할을 한다. 데이터베이스의 기본 키가 된다.

<br/>
<br/>

## 카디널리티와 참여도

카디널리티와 참여도는 관계의 규칙을 정의하는 두 가지 핵심 요소이다.  

<br/>

### 관계의 수량, 카디널리티 분석

카디널리티는 한 엔티티의 인스턴스(row)가 다른 엔티티의 인스턴스와 몇 개나 관계를 맺을 수 있는지를 나타내는 수량 제약이다. 1:1, 1:N, 1:M, M:N 관계를 따지는 것이다.  

카디널리티는 엔티티 인스턴스(row) 하나가 다른 엔티티의 인스턴스와 맺을 수 있는 최대 숫자를 기준으로 표기한다.  
- 1(하나): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 최대 1개의 관계를 가질 수 있을 때 사용한다.
- N(하나 이상): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 1개 이상, 즉 여러 개의 관계를 가질 수 있을 때 사용한다.  

<br/>

### 관계의 필수 여부, 참여도 분석

참여도는 한 엔티티의 인스턴스가 관계에 반드시 참여해야 하는지(필수), 아니면 참여하지 않을 수도 있는지(선택)를 결정한다.  

 개념적 모델링 단계는 RDBMS를 포함한 특정 기술에 종속되지 않기 때문에 외래키는 표함되지 않으며 엔티티간의 관계는 관계선으로 표한한다.  

<br/>
<br/>

## ERD

엔티티, 속성, 식별자, 관계, 카디널리티, 참여도를 하나의 그림으로 표현한 것이 ERD(Entity-Relationship Diagram)다.  

ERD를 그리는 방법은 '피터 챈 표기법'과 '까마귀발 표기법'이 있는데 주로 까마귀발 표기법이 사용된다. 까마귀발 표기법이 정보 밀도와 가독성이 좋고 표현이 직관적이다. 그리고 Dbeaver, ERDCloud 등 많은 데이터베이스 도구가 까마귀발 표기법을 기본으로 지원한다.  

<br/>
<br/>

## 다대다(M:N) 관계 해결

다대다 관계는 물리적으로 구현될 수 없으며, 관계에 속한 데이터를 저장할 장소가 없다. 이 문제를 해결하기 위해서는 다대다 관계를 연관 엔티티로 바꾸어 해결해야 한다.  

<br/>
<br/>

## 용어 사전

프로젝트의 모든 이해 관계자들은 같은 비즈니스 용어를 사용하는 것이 중요하다.  
개념적, 논리적 모델링 단계에서는 비즈니스 담당자들과 원활한 소통을 위해 한글 용어를 사용하는 경우가 많으며, 물리적 모델링 단계에서는 이 한글 용어들을 정한 규칙에 따라 영어로 정확하게 변환해야 하는데 이 때 **용어 사전**을 만들어 관리하면 편리하다.  

용어 사전은 많은 개발자들과 협업에서 서로 다른 변수명, 함수명, 테이블명 등의 용어를 사용할 때 공통으로 사용되는 용어를 정리해서 혼란없이 진행할 수 있는 '프로젝트 용어의 헌법'과 같다.  

단순히 단어를 나열하는 것을 넘어, 실무에서는 보다 체계적이고 상세한 용어 사전을 사용하며, 용어를 역할별로 분류하고, 약어와 전체 영문명을 명확히 구분하며, 실제 시스템에서 어떻게 사용되는지 구체적인 예시를 함꼐 기록하는 것이 좋다.  

용어 사전은 프로젝트가 진행됨에 따라 지속적으로 업데이트해서 최신 상태를 유지하고, 팀원 모두가 쉽게 접근 및 편집할 수 있는 도구를 사용해서 관리해야 한다.  

<br/>
<br/>

# 개념적 모델링 - 실전

프로젝트를 시작하고 요구 사항읋 분석해서 설계를 시작할 때 시작부터 전체 기능을 준비하고 기간을 잡으면 시작부터 삐걱거릴 수 있다.  

기능을 설계할 때는 필수적인 핵심 기능 및 지금 당장 필요한 기능부터 설계를 시작하면 개발 기간을 단축시키고, 이후에 차근차근 필요한 기능을 추가하면서 서비스를 오픈하는 것이 좋다. 

노련하고 숙련된 개발자와 기획자는 프로젝트를 잘개 쪼개서 지금 당장 필요하거나 필요하지 않은 것들을 분리할 줄 알아야 한다.

<br/>
<br/>

## 개념적 모델링 - 설계 시작

### 1단계: 핵심 요구 사항 다시 정의하기 (MVP)

핵심 요구 사항을 다시 정의하는 이 과정을 MVP(Minimum Viable Product, 최소 기능 제품) 라고 한다.  

복잡한 기능인 외부 판매자 기능, 쿠폰, 리뷰, 장바구니 기능같은 2차 기능은 미루고 1차 기능(핵심 기능)을 위주로 구현하고 나중에 2차 기능을 추가 개발한다.  

**쇼핑몰 MVP 기능 명세서**  
- 회원: 고객이 가입하고 자신의 정보를 관리할 수 있어야 한다.
- 상품: 우리가 판매할 상품을 등록하고 관리할 수 있어야 한다.
- 주문: 회원이 상품을 구매할 수 있어야 한다.
- 결제: 주문에 대한 결제 정보를 기록하고 관리할 수 있어야 한다.
- 배송: '결제가 완료된' 주문의 배송 상태를 관리할 수 있어야 한다.

<br/>

### 2단계: 핵심 엔티티 도출

핵심 기능을 추려서 단순해진 요구 사항에서 엔티티를 찾는다.   

도출된 핵심 엔티티: `회원` , `상품` , `주문` , `결제` , `배송`

<br/>

### 3단계: 속성 정의 및 관계 설정

- `회원(Member)`: 회원id, 로그인id, 비밀번호, 회원명, 이메일, 주소
- `상품(Product)`: 상품id, 상품명, 상품 가격, 재고 수량
- `주문(Order)`: 주문id, 주문 상태, 배송지 주소, 주문 일시
- `결제(Payment)`: 결제id, 결제 수단, 결제 금액, 결제 상태, 결제 일시
- `배송(Delivery)`: 배송id, 배송 상태, 운송장 번호  

<br/>

엔티티 관계 확인
- 회원은 여러 번 주문할 수 있다.(1:N)
- 하나의 주문에 대해서 하나의 결제가 이루어진다.(1:1)
- 하나의 주문에 대해서 하나의 배송이 이루어진다.(1:1)
- 하나의 주문에는 여러 상품이 포함될 수 있고, 하나의 상품은 여러 주문에 포함될 수 있다.(M:N)  

<br/>

### 4단계: M:N관계 해소와 '연관 엔티티'

M:N 관계는 물리적으로 구현할 수 없기 때문에 연관 엔티티를 도입해야 한다. 우리는 '주문' 엔티티와 '상품' 엔티티 사이에 '주문 항목'이라는 연관 엔티티를 도입한다.  

## 개념적 모델링 - ERD 작성

ERD 설계도를 만들기 위한 툴은 `draw.io`를 사용한다.  

![shopping mall erd](/Database/images/01-erd.png)

개념적 모델링의 목표는 모든 속성을 나타내는 것이 아닌 기획, 개발 등 모든 사람들의 이해를 돕는 것이 목표로, 핵심적인 것을 나타내고 등록일, 수정일과 같은 거의 모든 엔티티에 들어가는 속성은 생략했다.

개념점 모델링에서는 특정 데이터베이스에 종속되지 않기 때문에 외래키를 표현하지 않았지만, 실무에서는 보통 관계형 데이터베이스를 사용하기 때문에 개념적 모델링과 논리적 모델링을 함께 처리하는 경우 외래키를 표시하기도 하며, 보통 개발자 이외의 기획자들도 외래키가 있다고 해서 이해를 어렵게하지는 않는다.  

<br/>
<br/>
<br/>

# 논리적 모델링

논리적 모델링은 개념적 모델링에서 만든 청사진을 관계형 데이터베이스 구조에 맞게 변호나하는 과정이다. 엔티티는 **테이블**로, 속성은 **컬럼**으로 바꾸고, 각 테이블의 **기본 키(Primary Key)** 와 테이블 간의 관계를 표현하는 **외래 키(Foreign Key)** 등을 정의한다.

<br/>

## 키의 중요성

논리적 모델링은 특정 RDBMS에 종속되지 않는 순수한 데이터 구조를 설꼐하며, 가장 중요하게 다루어야 할 것이 '키(Key)'다.  

키는 데이터베이스 테이블의 각 행(Row)을 유일하게 식별할 수 있는 장치다. 키는 데이터를 찾는 용도 뿐만 아니라 테이블과 테이블을 연결해 관계를 맺어주고, 데이터 중복 및 잘못 입력되는 것을 막는 무결성 제약조건의 역할도 수행한다.  

<br/>

### 키(Key)

키는 테이블에 있는 각각의 행을 고유하게 식별할 수 잇는 하나 이상의 컬럼 집합이다.

#### **기본키(Primary Key - PK)**  
- 테이블의 모든 행을 유일하게 식별하는 대표 키다.
  - NULL 값을 가질 수 없다.(NOT NULL)
  - 반드시 유일해야 한다.(UNIQUE)
  - 값이 변하지 않아야 한다.(불변성)

#### **후보키(Candidate Key)**
- 기본 키가 될 수 있는 후보들을 말하며, 유일성과 최소성을 모두 만족하는 키를 말한다. 
  - 유일성(Unique): 모든 행을 서로 구분할 수 있어야 한다.
  - 최소성(Minimality): 행을 유일하게 식별하는 데 꼭 필요한 최소한의 컬럼만 포함해야 한다.

#### **대체 키(Alternate Key)**
- 후보 키 중에서 기본 키로 선택되지 않은 나머지 키들을 말한다.
- 회원 테이블에서 `member_id`가 기본 키로 선택됐다면, 유니크한 값으로 설정된 `email`, `phone`과 같은 속성은 대체 키가 된다.  

#### **외래 키(Foreign Key - FK)
- 테이블간의 관계를 연결하는 역할을 하는 중요한 키다.
- 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하는 것이다.

<br/>

## 자연 키 vs 대리 키

모든 테이블에서는 각 행을 식별하는 기본 키(PK)가 반드시 필요한 데, 기본 키를 찾는 과정에서 두 가지 후보인 자연 키와 대리 키를 만나게 된다.

### 자연 키

자연 키(Natural Key)란 우리의 비즈니스 로직 안에서 자연스럽게 발생하는, 의미를 가진 데이터를 기본 키로 사용하는 것을 말한다. `회원`의 이메일, `도서`의 ISBN 등이 자연키가 될 수 있다.  

자연키는 직관적이고, 비즈니스 규칙상 고유해야 하는 값을 PK로 지정하므로 중복 방지가 되지만, **변경 가능성**이 있다는 치명적인 단점이 있다.  

현대 데이터베이스 설꼐의 가장 중요한 원칙 중 하나는 "PK의 불변성"인데, 비즈니스 로직에 종속되는 자연 키는 이 원칙을 지키기 힘들다.  

<br/>

#### 문제 1 - 참조 무결성

회원 테이블(이메일, 이름, ...)과 주문 테이블(이메일, 주문 시간, ...)이 있을 때 주문 테이블은 회원 테이블의 이메일을 FK로 참조할 때 회원 테이블의 이메일이 변경될 수 있다면, 주문 테이블이 참조하던 회원 테이블의 이메일은 참조 무결성을 위배하게 된다.

#### 문제 2 - 연쇄 업데이트

문제 1에서 그렇다면 "양쪽 모두를 업데이트 하면 되는 것 아닌가?"라는 생각을 할 수 있는데, 실무에서 테이블이 매우 많을 것인데 이러한 연쇄 업데이트는 데이터베이스 서버의 엄청난 부하를 주게 된다.  

#### 문제 3 - 데이터 역사성 훼손

PK를 변경하게 되면 이전에 갖고 있었던 PK값의 로그가 모두 최신의 것으로 변경되어 데이터 역사성을 훼손하게 된다.  

#### 문제 4 - 외부 시스템과의 연동 문제

`member@old.com` 회원의 주문 정보를 외부 배송 시스템에 전달해서 배송 상태를 추적하고 있는데, 회원 정보가 `member@new.com`으로 변경되면, 우리 시스템과 와부 배송 시스템간의 동기화가 깨진다. 고객이 반품을 요청하거나 환불을 요청했을 때 배송 시스템과 우리 시스템상의 데이터가 일치하지 않아 오류가 발생하게 된다.  

<br/>

우리가 변경되지 않을 것이라고 생각하는 주민등록번호도 나라에 요청해서 변경될 수 있다.

<br/>

### 대리 키

자연키가 가진 '변경 가능성'이라는 치명적인 문제를 해결하기 위한 것이 대리 키(Surrogate Key)다. 인조 키(Artificial Key)라고도 한다.  

대리 키의 핵심은 비즈니스 로직과 완전히 무관한, 오직 데이터를 식별하기 위한 용도로만 존재하는, 임의의 값을 기본 키로 사용하는 것이다. UUID나 순차적으로 증가하는 1, 2, 3 ... 과 같은 값이 있다. 보통 `AUTO_INCREMENT`로 순차적인 값일 만들어서 사용한다.  

`member_id`를 `AUTO_INCREMENT`를 사용한 순차적으로 저장되는 대리 키 값을 PK로 사용할 때, 이 값은 비즈니스 로직과 연관이 없기 때문에, 이메일, 이름 등을 변경해도 절대 변하지 않는다. 이처럼 비즈니스 로직의 유연성을 확보할 수 있다.  

<br/>

### 자연 키의 올바른 사용

자연 키는 이제 PK를 대리 키에 넘기고, 비즈니스적으로 고유해야 하는 모든 컬럼에 `UNIQUE` 제약조건을 설정하면 된다.  

PK를 대리 키로 사용하고 `email`을 `UNIQUE`로 설정하면 다음 이점을 얻을 수 있다.
- 관계의 안정성: 불변의 대리 키가 모든 외래 키 관계의 중심을 잡아준다.
- 데이터 무결성: `UNIQUE` 제약 조건이 `email` 중복을 데이터베이스 차원에서 방지한다.
- 조회 성능: `UNIQUE` 제약조건을 설정하면 인덱스가 자동 생성되므로 `email`을 통한 조회 성능도 보장된다.  

<br/>

**현재 데이터베이스 설꼐에서 이처럼 대리 키를 사용한 PK 설정이 사실상 표준 방식이다.**

<br/>

## 자연 키 vs 대리 키 - 성능 트레이드 오프

### 자연 키 사용의 장점

비즈니스 요구사항을 봤을 때 자연 키(ex. `email`)만으로 데이터를 조회하는 경우가 대부분이라면, 조인 없이 해당 테이블에서 바로 원하는 정보를 얻을 수 있다. 하지만 대리 키를 사용할 때는 조인을 통해 이메일을 찾아야 한다.  
이처럼 자연 키를 사용하면 조인을 생략할 수 있어서 조회 성능이 더 좋을 수 있다.  

<br/>

### 자연 키 사용의 단점

#### 단점 1 - 외래 키 크기

자연 키가 `VARCHAR(50)` 처럼 긴 문자열이라면 참조하는 모든 자식 테이블에서 이 긴 문자열 컬럼을 가지고 있어야 한다.
- 일반적으로 대리 키로 사용하는 `BIGINT`(8바이트)에 비해 많은 디스크 공간을 차지한다.
- 테이블과 인덱스의 크기가 커지면 메모리에 한 번에 올릴 수 있는 데이터 양이 줄어들고, 조인 연산 시 비교해야 할 데이터 크기가 커져 메모리, CPU 사용량도 커지며 서버 성능 저하로 이어진다.  

#### 단점 2 - 인덱스 단편화와 쓰기 성능 저하

`email`과 같은 자연 키는 알파벳 순이나 가입 순서와 무관하게 생성되는데, 이런 상황에서 데이터에비스는 정렬된 상태로 인덱스에 저장해야 하므로 기존 데이터 'a...', 'f...'으로 이루어진 것에 'b...' 데이터를 삽입하는 과정에서 인덱스 페이지를 내누는 페이지 분할(Page Split)이 빈번하게 발생된다. 페이지 분할은 새로운 페이지를 할당하고 기존 데이터를 옮기는 복잡하고 비용이 큰 작업이다.  
이 과정에서 인덱스 내부에 빈 공간이 많이 생기는 단편화(Fragmentation)가 심해지고, 이는 쓰기 성능을 저하시킨다.

<br/>

### 대리 키 사용의 장점

#### 장점 1 - 뛰어난 쓰기 성능

`AUTO_INCREMENT`나 `SEQUENCE`를 사용하는 대리 키는 항상 이전 값보다 큰 숫자를 순서대로 만들어낸다.  
이는 페이지 분할을 거의 일으키지 않아 인덱스 단편화 문제가 발생하지 않아 매우 빠르고 효율적인 쓰기 성능을 제공한다. MySQL의 InnoDB 엔진은 `AUTO_INCREMENT` 처럼 순서대로 생성되는 대리 키 방식에 최적화된 저장 성능을 제공한다.  

#### 장점 2 - 외래 키 크기 최소화

`BIGINT` 타입의 대리 키는 8바이트 고정 크기를 가지며, `VARCHAR(50)` 같은 가변 길이 문자열보다 훨씬 작고 효율적이다.

<br/>

### 대리 키 사용의 단점

#### 단점 1 - 추가 조인 발생

대리 키를 사용하면 특정 비즈니스 데이터를 얻기 위한 과정에서 추가 조인이 필요할 수 있다. 하지만 대부분의 경우 추가 조인으로 인한 약간의 성능 저하보다는 대리 키가 제공하는 다른 수많은 이점(쓰기 성능, 데이터 크기, 유연성)이 훨씬 크다.  

#### 단점 2 - 추가 인덱스 필요

대리 키를 PK로 사용한다는 것은, 원래 자연 키로 사용하려던 컬럼을 이제 일반 컬럼으로 관리하는 것이기 때문에, `email` 같은 자연 키의 조회 성능을 보장하고 중복 방지를 위해 UNIQUE 인덱스를 반드시 생성해야 한다. 이는 추가 공간을 사용하고 약간의 쓰기 성능 저하를 감수해야 한다.  
하지만 대리 키는 데이터 모델의 안정성, 유연성, 쓰기 성능의 더 큰 이점을 주기 때문에 대리 키를 PK로 사용한다.

<br/>

## 자연 키 vs 대리 키 - 현대적인 설계

현대적인 데이터베이스 설계에서는 **거의 모든 경우에 대리 키 사용을 강력히 권장한다.**  

자연 키는 비즈니스 로직과 데이터의 '신원(ID)'를 강결합 시키는데, 대리 키는 데이터의 신원(ID)를 비즈니스 로직으로부터 완전히 분리시켜 느신한 결합을 이루게 해준다. 이는 유언성과 안정성이 증가하게 된다.  

<br/>

## 복합 키

현실 세계의 데이터를 논리적으로 표현하려고 할 때 자연스러운 식별자인 자연 키(Natural Key)를 찾기 위해 노력하는데, 이 식별자가 항상 단일 컬럼으로는 표현되지 않는다.  

```sql
CREATE TABLE movie_reservation (
    movie_title VARCHAR(100) NOT NULL, -- 영화 제목
    screening_dt DATETIME NOT NULL, -- 상영 시작 시간
    seat_number VARCHAR(10) NOT NULL, -- 좌석 번호
    reserver_id BIGINT NOT NULL, -- 예매자 id
    
    -- 복합키: movie_title + screening_dt + seat_number를 기본 키로 설정
    PRIMARY KEY (movie_title, screening_dt, seat_number)
);
```
좌석 예매를 식별하기 위해서는 영화 제목, 상영 시작 시간, 좌석 번호라는 이 세가지 값이 필요하다. 복합 키를 사용하면 데이터베이스는 세 컬럼의 조합이 중복되어 삽입되는 것을 막아 데이터의 유일성을 보장한다.

<br/>

### 자연 키를 복합 키로 사용하는 예시에서 발견되는 문제점

복합 키는 자연 키 기반이므로 비즈니스 변화에 취약하다. 영화 제목의 오타로 변경해야 할 때 연관된 테이블 모두를 변경해야 한다. 즉, 변경 가능성으로 인한 불안정성이 있다.

다른 테이블에서 복합 키를 외래 키로 참조할 때, 모든 컬럼을 복제해야 하기때문에 복잡성이 증가한다.  

복합 키는 직관적이지 않으므로 단일 키처럼 `WHERE id = 1`과 같이 조회할 수 없어 쿼리가 길어지고 조인 시에도 `ON` 절에서 복합 키를 모두 비교해야 하기 때문에 오류 발생이 쉽다. 또한 ORM에서 복합 키를 다루려면 별도의 식별자 클래스를 만드는 등 추가적인 매핑 로직이 필요해 개발 복잡도가 증가한다.  
시스템이 성정해 '상영관 번호'같은 새로운 조건이 추가된다면 기본 키의 구성이 바뀌어야 하는데 테이블의 구조변경 및 연관된 모든 테이블이 변경되야 하므로 확장에 어려움이 생긴다. 

<br/>

### 복합 키로 발생하는 문제 해결

복합 키로 인한 문제들을 해결하기 위한 대안은 대리 키를 사용하는 것이다. 대리키는 비즈니스와 무관한 값을 사용하여 불변성을 보장하고, 하나의 컬럼만 사용하기 때문에 간단하다.  

```sql
-- 예매 테이블 (대리 키 사용)
    CREATE TABLE movie_reservation (
    reservation_id BIGINT NOT NULL AUTO_INCREMENT, -- 대리 키 PK
    movie_title VARCHAR(100) NOT NULL,
    screening_dt DATETIME NOT NULL,
    seat_number VARCHAR(10) NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    PRIMARY KEY (reservation_id),
        
    -- 자연 키 부분에 UNIQUE 제약으로 데이터 무결성 보장
    UNIQUE KEY uq_movie_reservation (movie_title, screening_dt, seat_number)
);
```
- `reservation_id`는 절대 변하지 않으므로, 비즈니스적 변경이 발생해도 안전하다.
- 다른 테이블에서 단일 컬럼(대리 키)만 참조해도 되므로, 외래 키의 참조가 단순해진다.
- 크기가 작고 타입이 일관된 `BIGINT`는 여러 컬럼이 조합된 복합키보다 인덱싱과 조인 연산에서 훨씬 빠르다.
- 물리적인 기본키의 책임과 비즈니스 식별자(UNIQUE KEY로 묶은 값)를 분리해서 모델이 더 명확하고 유연해진다.  

대리 키의 명백한 장점 덕분에 현대적인 데이터베이스 설계는 아래 조합이 사실상의 표준으로 자리잡았다.
- 기본 키(PK)는 대리 키를 사용한다.
- 비즈니스를 다루는 자연 키는 `UNIQUE` 제약조건으로 설정한다.

<br/>

### 다대다 관계와 복합 키

'주문', '상품' 다대다 관계를 해소하기 위한 연관 테이블 '주문항목'의 PK를 설정하는 방법
- `order_id`, `product_id`를 복합 PK로 설정한다.
- 대리 키를 PK로 사용하고, `order_id`, `product_id`는 UNIQUE 제약조건을 설정한다.  

다대다 관계에서 복합 키를 PK로 사용했을 때 무결성 보장 및 테이블 구조만 봐도 주문과 상품의 관계를 나타냄을 알 수 있다.  
하지만 PK가 너무 뚱뚱해지고, 다른 테이블에서 참조했을 때 복합 키를 참조해야 하는 확장성의 제약, ORM의 사용이 불편해지는 여러 단점이 있다.  

다대다 관계에서 대리 키를 PK로 사용하면 기본 키가 단순해지며, 비즈니스 제약은 UNIQUE로 설정해서 사용하면 된다. 대리 키는 다른 테이블에서 일관되게 참조 가능하므로 구조가 단순하고 명확해진다. 그리고 UNIQUE 제약조건으로 복합 키와 같은 역할 수행도 가능하며, ORM에서도 대리 키는 일반적인 엔티티처럼 편하게 사용할 수 있다. 
UNIQUE 인덱스가 별도로 생성되는 단점은 있지만 현대의 컴퓨터 성능은 높아져가고 있기 때문에 무시할 수 있는 수준이다.

결론적으로 현대적인 데이터베이스 설계에서는 다대다 관계를 위한 연관 테이블도 대리 키를 기본 키로 사용하는 것을 권장한다. 이 방법은 복합키의 데이터 정합성 보장이라는 장점 및 대리키의 단순성, 불변성, 확장성이라는 장점을 모두 취할 수 있다.  

<br/>
<br/>
<br/>

## 관계

관계의 2대 핵심 요소는 **카디널리티(Cardinality)**와 **참여도(Optionality)**로 이 두가지를 어떻게 조합하느냐에 따라 관계의 성격이 결정된다.
- 카디널리티: 한 테이블의 행이 다른 테이블의 행과 몇 개나 연결될 수 있는지를 나타낸다.(1:1, 1:N, N:1, M:N)
- 참여도: 한 테이블의 행이 관계를 맺고 있는 다른 테이블에 반드시 대응되는 행을 가져야 하는지(필수 참여), 갖지 않아도 되는지(선택 참여)를 나타낸다.

<br/>

## 참여도

참여도는 한 엔티티가 관계에 필수적으로 참여해야 하는지(Mandatory), 아니면 선택적으로 참여할 수 있는지(Optional)를 나타낸다.  

논리적 모델링에서 이 참여도는 외래 키(FK) 컬럼의 NULL 허용 여부로 구현된다. 하지만 이 제약조건만으로는 모든 비즈니스 규칙을 강제할 수 는 없다. 구현 방법과 한계를 확인한다.

<br/>

![팀-멤버 관계](/Database/images/02-relation.png)

회원은 팀에 소속될 수도 있고, 소속되지 않은 상태일 수도 있다. 테이블을 생성할 때 `team_id` 속성에 `NOT NULL` 조건을 사용하면 회원은 팀에 필수적으로 소속되야 한다.  

위 테이블에서 회원은 팀에 필수적으로 소속되게 강제하거나, 선택적으로 팀에 소속되게 할 수 있다. 하지만 팀이 회원을 가지지 않아도 된다거나, 한명 이상의 회원을 필수적으로 가져야 한다는 규칙은 강제할 수 없다.  
이는 연관 관계의 부모 테이블(제약을 걸 대상)에는 외래 키 컬럼이 존재하지 않기 때문이다.  

이런 문제를 해결하려면 애플리케이션 계층에서 로직으로 해결해야 한다. 팀을 생성할 때 회원을 같이 생성해서 팀을 지정하도록 해야 한다.  

<br/>

### ERD와 비즈니스 규칙의 중요성

데이터베이스 제약조건으로 구현하기 어렵다고 해서, ERD에 원래의 비즈니스 규칙을 표현하지 않으면 안된다.
- ERD: 데이터베이스의 물리적 제약을 넘어, 원래의 비즈니스 규칙을 그대로 표현해야 한다. '팀은 반드시 한명 이상의 회원을 가져야 한다'는 규칙이 잇다면, ERD는 이 관계가 명확히 그려져야 한다.
- 데이터베이스 DDL: ERD에 표현된 규칙 중, 데이터베이스가 제약조건으로 강제할 수 있는 부분까지만 구현한다.
- 애플리케이션 코드: DDL로 구현하지 못한 나머지 비즈니스 규칙을 책임지고 구현해서 데이터의 무결성을 환상한다.

<br/>

### 일대다(1:N) 다대일(N:1) 관계 - 외래 키 위치

일대다 또는 다대일 관계에서 외래 키는 항상 다(N)쪽에 위치해야 한다.  
외래 키를 다(N)쪽에 두어야 제1정규형의 원자성을 지킬 수 있으며, 유연하고 확장 가능한 테이블을 설계할 수 있다.

<br/>

### 일대다(1:N) 다대일(N:1) 관계 - 조인과 뻥튀기

다대일(N:1) 관계에서 조인을 할 때는 데이터가 뻥튀기 되지 않지만, 일대다(1:N) 관계에서 조인을 할 때는 데이터가 뻥튀기 될 수 있음을 유의해야 한다.  

<br/>

### 일대일(1:1) 관계

일대일 관계는 일대다 관계만큼 흔하지 않은데, 일대일 관계는 그냥 하나의 테이블로 합치는 것이 효율적인 경우가 많기 때문이다.  

#### 일대일 관계를 사용하는 경우

- 성능 최적화를 위한 분리: 회원 테이블에서 회원 상세 프로필 정보를 저장한다고 가정할 때, 이 컬럼들은 로그인이나 회원 목록 조회에서는 필요없는데, 이 모든 컬럼이 회원 테이블에 포함될 때 단순히 회원 이름만 조회하는 경우에도 디스크에서 불필요하게 큰 데이터를 읽어야하는 성능 저하 문제가 발생한다.
- 보안 강화를 위한 분리: 회원의 정보 중에는 민감한 개인정보가 있을 수 있는데, 이런 정보를 회원 테이블에 두는 것은 보안상의 문제가 있을 수 있기 때문에 테이블을 분리할 수 있다.
- 선택적 정보(0 or 1) 표현 및 확장: 쇼핑몰에서 모든 회원들이 판매자는 아니다. 이 때 판매자 정보를 회원 테이블에 포함하기 보다는 판매자(Seller) 테이블을 분리해서 사용할 수 있다.
- 비즈니스 모델에 따른 분리: 쇼핑몰 비즈니스에서 '주문 처리'와 '배송 처리'는 라이프 사이클이 다르기 때문에 분리해서 사용한다. 이는 서로 다른 관심사를 깔끔하게 관리할 수 있고, 배송 관련 문제가 발생했을 때 주문 테이블의 영향 없이 배송 테이블만 확인하여 처리할 수 있게 된다.  

<br/>

```sql
-- 주 테이블
CREATE TABLE member (
    member_id BIGINT NOT NULL AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    PRIMARY KEY (member_id)
);

-- 보조 테이블
CREATE TABLE member_detail (
    member_detail_id BIGINT NOT NULL AUTO_INCREMENT, -- 고유 PK
    member_id BIGINT NOT NULL, -- FK + UNIQUE
    mbti VARCHAR(10) NULL,
    
    PRIMARY KEY (member_detail_id),
    UNIQUE KEY uq_member_id (member_id), -- 1:1 관계의 핵심
    CONSTRAINT fk_detail_member FOREIGN KEY (member_id) REFERENCES member (member_id)
);
```

### 일대일 관계의 외래 키 위치

일대일 관계에서 외래 키를 두는 방법은 보조 테이블에 외래 키를 두는 방법(보조 테이블 FK -> 주 테이블 PK 참조)과 주 테이블에 외래 키를 두는 방법(주 테이블 FK -> 보조 테이블 PK 참조)이 있는데 실무에서는 **보조 테이블에 외래 키를 두는 방법**을 권장한다.

#### 보조 테이블에 외래 키 두기

- 장점
  - 주 테이블이 보조 테이블의 존재를 알지 못해도 된다. 이는 주 테이블의 독립성과 시스템의 확장성을 유연하게 해준다.  
  - '회원 상세정보'는 '회원'에 종속되는 개념으로, 이 구조는 비즈니스 논리와 정확히 일치해 모델을 이해하기 쉽게 해준다.
  - 상세정보가 없는 회원은 `member_detail` 테이블에 데이터를 추가하지 않으면 그만이다. `member` 테이블에는 NULL을 허용하는 불필요한 외래 키 컬럼이 추가되지 않아도 되므로 깔끔해진다. 
  - 일대일 관계에서 일대다 관계로 변경해야 할 필요가 있을 때 FK 적용된 유니크 제약조건만 제거하면 된다.(첨부파일을 단일로 사용하다가 여러 개를 허용하는 경우를 생각해보자)
- 단점
  - 회원 상세정보를 확인할 때 `member_detail` 테이블의 데이터를 확인해야 한다는 단점이 있다.

#### 주 테이블에 외래 키 두기

- 장점
  - 주 테이블이 모든 참조를 관리하므로, 주 테이블만 조회해도 보조 정보의 존재 여부를 바로 확인할 수 있다.
  - 주 테이블의 보조 테이블 FK 컬럼이 NULL 인지 확인만 해도 상세정보의 유무를 즉시 알 수 있다. JOIN, EXIST를 사용하지 않아도 된다.
- 단점
  - 다른 일대일 관계가 추가됐을 때 주 테이블에 외래 키 컬럼을 추가해야한다. 이는 테이블이 추가될 때마다 테이블 구조를 변경해야 하므로 확장성이 나빠진다.
  - 일대일 관계에서 일대다 관계로의 확장이 사실상 불가능하며, 테이블 구조를 완전히 재설계 해야 한다.
  - 모든 회원이 상세정보를 갖는것은 아니기 때문에 NULL 값을 허용해야 한다. 이는 불완전한 정보가 들어갈 수 있음을 나타낸다. 상세정보가 필수라면 NOT NULL을 사용할 수 있다.
  - 데이터 추가 로직이 상대적으로 복잡해진다.

<br/>

### 일대일 관계에서 일대다 관계로 확장

일대일 관계에서는 주 테이블의 PK를 보조 테이블의 FK로 참조하며 유니크 제약 조건이 걸려있다.  
일대일 관계를 일대다 관계로 확장하기 위해서는 다음 과정을 진행해야 한다.  

1. 보조 테이블의 FK 제약 조건을 삭제한다. (MySQL에서는 인덱스를 변경 전에 FK를 먼저 삭제해야 한다.)
2. FK 였던 컬럼의 UNIQUE INDEX를 삭제한다.
3. 외래 키 제약 조건을 다시 추가한다. 외래 키 제약조건이 적용되면 일반 인덱스가 생성된다.

<br/>

### 일대일 관계에서 주 테이블에 FK를 고려할 경우

#### 관계가 선택이 아닌 필수일 경우(고려해볼 수 있음)

'모든 회원은 반드시 상세정보를 가져야 한다'와 같이 관계가 필수일 경우 주 테이블인 회원 테이블에 상세정보(`member_detail_id`)를 FK로 사용하고 `NOT NULL` 조건을 사용할 수 있다.  
이는 회원이 상세정보 없이 생성되는 것을 원천적으로 차단하며 데이터 정합성을 유지할 수 있다.  

이 방식은 두 테이블이 논리적으로 강하게 묶여 있어 사실상 하나의 테이블처럼 취급될 때 사용을 고려해볼 수 있지만, 확장성을 고려하면 보조 테이블에 FK를 두는 방식을 사용하고, 애플리케이션 레벨에서 데이터 존재 여부를 검증하는 것이 더 유연한 해결책일 수 있다.  
너무 하나의 방식으로 치우치지 말고 상황을 고려해서 선택하면 좋을 것 같다.  

#### 주 테이블에 외래키를 고려할 수 있는 다양한 경우

- 보조 테이블이 주 테이블보다 먼저 생성, 관리되는 경우
- 보조 테이블이 주 테이블의 필수 구성 요소인 경우
- 조회 빈도가 매우 높고, JOIN 비용을 최소화해야 하는 경우

<br/>

## 다대다(M:N) 관계

관계형 데이터베이스는 테이블 두 개만으로는 다대다 관계를 표현할 수 없다.  
테이블 두 개만으로는 양쪽의 '다(Many)' 관계를 모두 수용할 수 없는 것이 관계형 데이터베이스의 본질적인 한
계다. (제1정규형 위반)

<br/>

### 다대다 관계 해결 - 연결 테이블

다대다 관계를 푸는 표준 해법은 중간에 연결 테이블을 만들어서 기존의 다대다 관계를 두 개의 일대다 관계로 풀어내는 것이다.  

연결 테이블에서 핵심은 관계 자체를 하나의 독립된 데이터로 보고, 그것을 테이블로 모델링 했다는 것이다.

연결 테이블은 두 테이블 사이에서 발생할 수 있는 수많은 관걔의 경우의 수를 하나하나 독립된 데이터로 저장하는 공간이다. 관계를 구체적인 데이터로 만들어 테이블에 담는 순간, 기존의 복잡했던 다대다 관계는 아주 명확한 두 개의 일대다 관계로 자연스럽게 해소된다.  

<br/>

### 다대다 관계 - 속성

다대다 관계를 해소한 연결 테이블은 대부분의 경우 관계 자체에 대한 추가적인 속성을 가지게 된다.  

'주문'과 '상품'의 관계에서 다대다 관계를 해소할 때 주문할 당시의 상품의 주문 금액과 상품 수량은 관계 그 자체에 속하는 속성들이며 '주문항목'이라는 의미를 가지는 하나의 독립적인 연관 엔티티(Associative Entity)로 설계해야 한다.  

연결 테이블은 단순히 기술적인 해결책이 아니라 그 자체로 중요한 비즈니스 의미를 갖는 핵심 엔티티인 경우가 많다.    

이론적으로 개념적 모델의 다대다 관계가 논리적 모델링 단계에서 연결 테이블로 풀어진다고 하지만, 실무에서는 대부분의 다대다 관계가 이런 '관계 속성'을 갖으므로, 개념적 모델링 단계에서부터 이미 별도의 엔티티로 식별되는 경우가 대부분이다.  

<br/>

#### 연관 엔티티 이름

연관 엔티티는 두 테이블 간의 의미 있는 이름을 사용하는 것이 좋다.  

우리는 주문과 상품에서 파생된 연결 테이블의 이름을 '주문 항목'이라는 이름을 사용하고 `order_item`이라는 테이블명을 사용한다.  

```sql
CREATE TABLE order_item (
    order_item_id BIGINT NOT NULL AUTO_INCREMENT, -- 주문 상품 ID (PK)
    order_id BIGINT NOT NULL, -- 주문 ID (FK from orders)
    product_id BIGINT NOT NULL, -- 상품 ID (FK from product)
    order_price INT NOT NULL, -- 주문 당시 가격 (관계 속성)
    order_quantity INT NOT NULL, -- 주문 수량 (관계 속성)
    
    PRIMARY KEY (order_item_id),
    
    -- 한 주문에 동일한 상품이 중복으로 들어가는 것을 방지
    CONSTRAINT uq_order_item UNIQUE (order_id, product_id),
    CONSTRAINT fk_order_item_orders FOREIGN KEY (order_id) REFERENCES orders (order_id),
    CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (product_id)
);
```

<br/>

### 속성이 있는 다대다 관계와 속성이 없는 다대다 관계

속성이 없는 다대다 관계는 개념적 모델링에서는 M:N 관계로 표현되지만, 논리적 모델링에서는 연결 테이블을 통해 1:N 관계로 풀어내야 한다.  

속성이 있는 다대다 관계는 개념적 모델링 단게에서부터 '연관 엔티티'가 등장하여 1:N 관계로 표현되며, 논리적 모델링에서는 이를 그대로 테이블로 구현한다.

<br/>

## 식별 관계 vs 비식별 관계

ERD에서 식별 관계는 실선, 비식별 관계는 점선으로 표시된다.   

#### 식별 관계 
- 부모 테이블의 기본 키를 물려받아 자식 테이블의 '기본 키(PK)의 일부'것 사용하는 것이다. 부모가 자식을 식별하는 데 사용되는 관계라는 의미이다. 
- 자식의 식별자가 부모의 식별자를 포함해야만 완전해지는 관계이다.
- 부모 테이블의 PK를 받아서 자식 테이블의 PK + FK로 사용한다.

#### 비식별 관계
- 비식별 관계: 부모 테이블의 기본 키를 단순히 '일반 컬럼'으로만 사용하는 것이다. 부모가 자식을 식별하는데 사용되지 않는 관계이다.
- 부모와의 관계가 자식의 존재를 식별하는데 필수적이지 않은 관계가 비식별 관계이다.
- 부모 테이블의 PK를 받아서 부모 테이블에서 받아온 PK는 일반 컬럼 + FK가 되고 자식 테이블은 별도의 고유한 PK를 갖는다.

두 경우 모두 받아온 부모의 키는 외래 키(FK)가 된다.  

용어의 의미를 정확이 이해하면 "두 엔티티의 관계가 논리적으로 얼마나 강하게 묶여 있는가?"라는 모델의 본질을 파악하는데 도움이 된다.  

<br/>


### 약한 엔티티 - 식별 관계, 강한 엔티티 - 비식별 관계

자식 엔티티가 부모 엔티티 없이는 존재 의미가 없거나 식별 자체가 불가능하면, 이 둘은 '강한 관계'로 묶여 있다고 하며, 개념적 모델링에서는 이를 '약한 엔티티(Weak Entity)'라고 한다.  
약한 엔티티는 스스로 존재할 수 없고 부모의 식별자를 자신의 식별자의 일부로 가져와야 완전해지며, 이는 논리적 모델링에서 식별 관계로 구현된다.  

자식 엔티티가 부모 엔티티 없이도 독립적으로 존재할 수 있고 자신만의 고유한 식별자를 가질 수 있다면, 이 둘은 '약한 관계'로 연결되어 있다고 보며, '강한 엔티티(Strong Entity)라고 한다.  
부모와의 연결은 단지 여러 관계중 하나일 뿐, 자식의 존재를 정의하지 않으며, 이는 논리적 모델링에서 비식별 관계로 구현된다.

<br/>

### 식별 관계의 문제점

- 유언성 부족: 부모와 자식이 PK로 강하게 묶여있기 때문에, 한번 맺어진 관계를 변경하는 것이 매우 어렵다.
- PK 컬럼의 전파와 복잡성 증가: 관계가 깊어질 수록(자식, 손자 테이블로 내려갈수록) 부모의 PK가 계속해서 누적되어 자식 테이블의 PK가 비대해지고 복잡해진다. 이는 JOIN이나 ORM 기술 사용의 복잡성을 가증시킨다.  

이런 문제점들 때문에 현대적인 데이터베이스 설계에서는 대부분 비식별 관계를 사용한다.  

식별 관계는 부모 테이블과 자식 테이블이 '강하게 결합'하여 한번 맺어진 관계를 변경하기 어렵게 하지만, 비식별 관계는 '느슨한 결합'을 유지하므로 비즈니스 로직 변경을 유연하게 대처할 수 있다.  

<br/>

### 비식별 관계를 사용해야 하는 이유

식별 관계는 '관계'와 '비즈니스 규칙'을 테이블의 '신원(PK)'에 직접 묶어버려 논리적으로는 명확해 보이지만, 비즈니스 규칙이나 데이터 소속 관계가 변경될 때 PK 자체를 흔들어 시스템 전체에 치명적인 영향을 준다.  

비식별 관계는 이들을 명확히 분리시킨다. 신원(PK)은 대리 키가 담당하고(불변), 관계(FK)는 외래 키가 담당하며 관계가 바뀌면 이 값만 수정가능하다. 그리고 비즈니스 데이터는 일반 컬럼이 담당하면 된다.    
이는 변경의 영향 범위가 최소화되고 시스템의 유연하고 견고하게 만든다.  

현대 애플리케이션 개발에서는 대부분 유연성과 확장성을 위해 비식별 관계를 선택한다.

<br/>

### 식별 관계 vs 비식별 관계 - SQL 쿼리, 성능

단일 식별자를 사용하는 비식별 관계는 데이터베이스 뿐만 아니라, 그 데이터를 사용하는 애플리케이션의 모든 계증(API, 비즈니스 로직, 데이터 접근 등)을 더 단순하고 견고하게 만들어주는 핵심적인 설계 원칙이다.  

데이터베이스의 인덱스를 사용할 때 식별 관계는 복합키로 묶이기 때문에 사용이 편할 수는 있지만, 실무에서는 비식별 관계에 FK에 인덱스를 추가하는 것은 어려운 일이 아니며(MySQL은 기본적으로 FK에 인덱스를 적용), 현대 데이터베이스 시스템에서는 일반적인 최적화 기법이다.  
인덱스를 FK에 하나 추가함으로써 식별 관계의 모든 단점(복잡성, 유연성 부족)을 피하고 비식별 관계의 장점(단순성, 확장성)을 모두 누릴 수 있다.

<br/>

### 일대일(1:1) 식별, 비식별 관계

```sql
CREATE TABLE member_identifying (
    member_id BIGINT NOT NULL AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    
    PRIMARY KEY (member_id)
);
CREATE TABLE member_detail_identifying (
    member_id BIGINT NOT NULL, -- PK + FK
    mbti VARCHAR(4) NULL,
    
    PRIMARY KEY (member_id),
    CONSTRAINT fk_detail_member_iden FOREIGN KEY (member_id) REFERENCES member_identifying (member_id)
);
```

일대일 관계에서 식별 관계는 부모 테이블의 PK를 그대로 자식 테이블의 FK이자 PK로 사용한다. 이는 논리적으로 하나의 개념이라는 점을 구조적으로 명확하게 표현할 수 있다.  
하지만 부모 테이블에 강하고 종속되므로 유연성이 낮아진다.(일대일 관계를 일대다 관계로 변경해야 한다면?)

비식별 관계는 독립적인 PK를 가지므로, 두 테이블의 결합도가 낮아진다. 이는 각 테이블을 독립적으로 관리하고 수정할 수 있게 해주기 때문에 유연한 관리가 가능하다.  
그리고 일관성있는 설계가 가능해져 전체 데이터베이스를 이해하고 유지보수하기 쉬워진다.  

<br/>

### 식별, 비식별 관계의 현대적인 설계 트랜드

#### 과거 식별 관계를 선호됐던 이유

- 논리적 명확성: '부모 없이 자식이 존재할 수 없다'는 논리적 관계를 데이터 구조에 직접적으로 표현할 수 있다.
- 저장 공간 절약: 예전처럼 저장 공간이 비쌌던 시절에는 대리 키를 사용한 PK의 별도 공간이 낭비라고 생각했다.
- 쿼리 최적화: 별도의 인덱스 생성 없이 PK 인덱스를 바로 활용할 수 있다는 장점이 있었다.

#### 비식별 관계가 대세가 된 이유

- 압도적인 유연성과 민첩성: 소프트웨어의 요구사항은 항상 변하며, 식별 관계의 강한 결합(Tight Coupling)은 이러한 변화에 대응하는 것을 극도록 어렵게 만든다. 비식별 관계의 느슨한 결합(Loose Coupling)은 PK의 변경 없이 관계나 비즈니스 규칙을 수정할 수 있기에 변화에 민첩하게 대응할 수 있다.
- 단순성과 일관성: 단순한 것이 최고로, 모든 테이블이 id라는 이름의 단일 대리키를 PK로 갖는 구조는 매우 단순하고 일관성 있다. 이는 개발자가 테이블 구조를 예측하기 쉬우며, JOIN 쿼리나 데이터를 다루는 로직을 작성하기가 수월해진다.  
- ORM 친화성: JPA, Django ORM 등 현대 애플리케이션 개발의 표준이 된 ORM 기술들은 엔티티가 독립적인 단일 식별자(PK)를 갖는 것을 기본으로 설계됐다. 비식별 관계는 ORM과 완벽하게 조화를 이루며 개발 생산성을 극대화한다. 반면, 복합키를 사용하는 식별 관계는 ORM에서 다루기 매우 번거롭고 추가적인 코드를 요구한다.  
- 비즈니스 로직과의 완벽한 분리: 비즈니스 규칙은 언제든 변할 수 있다. 테이블의 본질적인 신원(PK)을 이러한 비즈니스 값과 묶어버리는 것은 매우 위험한 설계다. 비즈니스와 무관한 대리키를 사용하는 비식별 관계는 이러한 외부 변화로부터 데이터 구조를 안전하게 보호하는 '방화벽' 역할을 한다.

<br/>

## 논리적 모델링 - 실전

개념적 모델링을 통해 비즈니스 요구사항을 ERD로 만들었고, 이제 논리적 모델링의 핵심인 키(key)와 관계(Relationship)를 이해하고 활용하여, 관계형 데이터베이스에 더 가까운 논리적 모델로 만들 것이다.  

### 개념에서 논리로

- 엔티티는 테이블로 변환된다.
- 속성(Attribute)은 컬럼(Column)으로 변환된다.
- 식별자(Identifier)는 기본 키(Primary Key)로 변환된다.
- 관계(Relationship)는 외래 키(Foreign Key)와 제약조건으로 변환된다.  

논리적 모델링은 관계형 데이터베이스를 사용하기로 정한 뒤, 어떤 관계형 데이터베이스를 사용할지 정하기전에, 데이터의 구조와 관계를 정의하는 단계다.  

물리적 모델링은 논리적 모델을 바탕으로, 실제 데이터베이스에 어떻게 데이터를 저장할지 구체적으로 정하는 단계이다.  

데이터베이스 설계에서 논리적 모델링(청사진)과 물리적 모델링(실제 구현)은 이론적으로 구현되지만, 실무에서는 개발 속도를 높이고 불필요한 수정을 줄이며, 처음부터 성능을 고려하기 위해 두 단계를 함께 진행하는 경우가 많다. 즉, 효율성을 위해 논리적 모델링과 물리적 모델링을 함께 진행할 때도 있다.    

![논리적 모델링 erd](/Database/images/03-logical_erd.png)  

<br/>

### 모델의 단순화와 트레이드 오프

현재까지 설계한 모델은 '주문', '배송', '결제'를 명확히 분리한 좋은 설계다.  

초기 스타트업의 MVP(Minimum Viable Product, 최스 기능 제품)일 때 초기 단계에서는 배송, 결제 시스템이 복잡하지 않아 빠른 개발과 단순성을 위해 테이블을 합치는 전략을 사용하기도 한다.  
이렇게 설계하면 주문 테이블을 조회해서 배송 정보를 한번에 볼 수 있다는 장점이 있다.  

하지만 '정규화'를 희행해 '단순성'을 얻는 트레이드 오프 관계로, 서비스가 성장하여 배송 로직이 복잡해지면, 주문 테이블에서 배송 컬럼들을 다시 분리해야 하는 날이 올 수 있다.  
우리는 일단 원칙에 충실한 설계를 배우고, 상황에 따라 이런 트레이드 오프를 고려할 수 있는 시야를 갖추는 것이 중요하다.  

<br/>

## 정규화

데이터베이스 설계에서 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터 일관성을 보장하며, 데이터 모델을 더 유연하게 만들기 위한 과정이다.  

정규화는 데이터를 정규형(Normal Form)이라는 규칙에 맞춰 변환하여 데이터가 중복되지 않고, 일관성 및 무결성을 유지하며, 데이터 이상현상(삽입, 수정, 삭제 이상)을 방지할 수 있다.

#### 함수 종속성

정규화를 이해하기 위한 필수적인 개념으로 함수 종속성이란, 테이블에서 컬럼의 값들이 다른 컬럼의 값을 유일하게 결정하는 관계(한 속성 또는 속성 집합의 값이 다른 속성 또는 속성 집합의 값을 결정하는 관계)를 의미한다. `X -> Y` 같이 표기하고, "X가 Y를 함수적으로 결정한다"라고 읽으며, X를 결정자(Determinant), Y를 종속자(Dependent)라고 한다.  

정규화는 함수 종속성 관계를 분석해서, 잘못된 종속 관계를 찾아내고 테이블을 분리해 올바른 종속 관계로 만들어가는 과정이다.

<br/>

### 제1 정규형

#### **제1 정규형(1NF)**
- 테이블의 모든 컬럼이 원자적인(Atomic) 값만을 가져야 한다.

#### 제 1 정규형 위반 테이블

`product_infos` 컬럼은 상품 ID, 상품명, 수량, 가격 등 여러 정보로 쪼갤 수 있으므로 원자적이지 않다.

```sql
-- 제1 정규형을 위반하는 테이블 생성
CREATE TABLE orders_1nf_violating (
    order_id INT NOT NULL,
    ordered_at DATETIME NOT NULL,
    member_id INT NOT NULL,
    member_name VARCHAR(50) NOT NULL,
    product_infos VARCHAR(255) NOT NULL -- 이 컬럼이 원자성을 위반한다.
);
```

| order_id | ordered_at          | member_id | member_name | product_infos                          |
|:---------|:--------------------|:----------|:------------|:---------------------------------------|
| 1001     | 2025-08-20 10:00:00 | 1 | 션 | 10:노트북:2:1500000, <br/> 15:키보드:1:50000 |
| 1002     | 2025-08-21 11:00:00 | 2 | 네이트  | 10:노트북:1:1500000 |
| 1003     | 2025-08-21 12:00:00 | 1 | 션 20:마우스:1:30000 |
<br/>

#### 제 1 정규형을 만족하도록 테이블 수정

제1 정규화를 적용하기 위해, 반복되는 상품 정보를 별도의 행으로 분리해야 한다.

```sql
-- 제1 정규형을 만족하는 테이블 생성
CREATE TABLE orders_1nf (
    order_id INT NOT NULL,
    member_id INT NOT NULL,
    member_name VARCHAR(50) NOT NULL,
    product_id INT NOT NULL,
    product_name VARCHAR(100) NOT NULL,
    product_price INT NOT NULL,
    order_quantity INT NOT NULL,
    ordered_at DATETIME NOT NULL,
    
    PRIMARY KEY (order_id, product_id) -- 기본 키를 (order_id, product_id) 복합키로 설정
);
```
| order_id | member_id | member_name | product_id | product_name | product_price | order_quantity | ordered_at          |
|:---------|:----------|:------------|:-----------|:-------------|:--------------|:---------------|:--------------------|
| 1001     | 1         | 션           | 10         | 노트북          | 1500000       | 2              | 2025-08-20 10:00:00 |
| 1001     | 1         | 션           | 15         | 키보드          | 50000         | 1              | 2025-08-20 10:00:00 |
| 1002     | 2         | 네이트        | 10         | 노트북          | 1500000       | 1              | 2025-08-21 11:00:00 |
| 1003     | 1         | 션           | 20         | 마우스          | 30000         | 1              | 2025-08-21 12:00:00 |

<br/>

### 제2 정규형

기존의 테이블에서 주문 시점의 가격인 `order_price` 컬럼을 추가한다.

| order_id | member_id | member_name | product_id | product_name | product_price | order_price | order_quantity | ordered_at          |
|:---------|:----------|:------------|:-----------|:-------------|:--------------|:------------|:---------------|:--------------------|
| 1001     | 1         | 션           | 10         | 노트북          | 1500000       | 1500000    | 2              | 2025-08-20 10:00:00 |
| 1001     | 1         | 션           | 15         | 키보드          | 50000         | 50000      | 1              | 2025-08-20 10:00:00 |
| 1002     | 2         | 네이트        | 10         | 노트북          | 1500000       | 1500000    | 1              | 2025-08-21 11:00:00 |
| 1003     | 1         | 션           | 20         | 마우스          | 30000         | 30000      | 1              | 2025-08-21 12:00:00 |

#### 기본 키 모두에 종속되는 컬럼들
- (`order_id`, `product_id`) -> `order_price`
- (`order_id`, `product_id`) -> `order_quantity`
- `order_price`와 `order_quantity` 는 기본 키 외에 외래키에도 종속된다.

#### 기본 키의 일부에만 종속되는 컬럼들
- `order_id` -> `member_id`
- `order_id` -> `member_name`
- `order_id` -> `ordered_at`
- 이 세 가지 컬럼은 `product_id`와 아무런 관련 없이 `order_id`에만 종속된다.

기본 키의 일부에만 종속되는 컬럼이 존재하는 것을 **부분 함수 종속(Partial Functional Dependency)** 이라고 한다. 부분 함수 종속은 데이터 중복 및 이상 현상을 일으킨다.  

<br/>

#### **제2 정규형(2NF)**
- 제1 정규형을 만족해야 한다.
- 테이블의 모든 커럼이 기본 키에 대해 완전 함수 종속(Fully Functional Dependency)이어야 하며, 부분 함수 종속이 없어야 한다.
- 결론적으로 기본 키에 속하지 않는 속성 모두가 기본 키에 완전 함수 종속이 되도록 해야 한다.

```sql
-- 1. orders 테이블 생성 (주문 정보)
CREATE TABLE orders_2nf (
    order_id INT NOT NULL,
    member_id INT NOT NULL,
    member_name VARCHAR(50) NOT NULL, -- 아직 3NF 위반 요소를 남겨둔다.
    ordered_at DATETIME NOT NULL,
    
    PRIMARY KEY (order_id)
);
-- 2. product 테이블 생성 (상품 정보)
CREATE TABLE product_2nf (
    product_id INT NOT NULL,
    product_name VARCHAR(100) NOT NULL,
    product_price INT NOT NULL,
    
    PRIMARY KEY (product_id)
);
-- 3. order_item 테이블 생성 (주문-상품 연결 정보)
CREATE TABLE order_item_2nf (
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    order_price INT NOT NULL,
    order_quantity INT NOT NULL,
    
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (order_id) REFERENCES orders_2nf (order_id),
    FOREIGN KEY (product_id) REFERENCES product_2nf (product_id)
);

```

<br/>

#### order_2nf

| order_id | member_id | member_name | ordered_at |
|:--|:--|:--|:--|
| 1001 | 1 | 션 | 2025-08-20 10:00:00 |
| 1002 | 2 | 네이트 | 2025-08-21 11:00:00 |
| 1003 | 1 | 션 | 2025-08-21 12:00:00 |

#### product_2nf

| product_id | product_name | price |
|:--|:--|:--|
| 10 | 노트북 | 1500000 |
| 15 | 키보드 | 50000 |
| 20 | 마우스 | 30000 |

#### order_item_2nf

| order_id | product_id | order_price | order_quantity |
|:--|:--|:--|:--|
| 1001 | 10 | 1500000 | 2 |
| 1001 | 15 | 50000 | 1 |
| 1002 | 10 | 1500000 | 1 |
| 1003 | 20 | 30000 | 1 |

부분 함수 종속이 사라져 완전 함수 종속이 되었지만, `orders_2nf` 테이블에는 데이터 중복이 남아있으며, 수정 이상의 문제가 남아있다. '션' 회원의 이름이 두 번 중복 저장됐는데, 이를 해결하는 것이 제3 정규화다.  

<br/>

### 제3 정규형

| order_id | member_id | member_name | ordered_at |
|:--|:--|:--|:--|
| 1001 | 1 | 션 | 2025-08-20 10:00:00 |
| 1002 | 2 | 네이트 | 2025-08-21 11:00:00 |
| 1003 | 1 | 션 | 2025-08-21 12:00:00 |

`order_2nf` 테이블에서 `member_id`, `ordered_at` 컬럼은 `order_id`에 잘 종속되어 있다. 하지만 `member_name`은 기본 키가 아닌 `member_id`에 종속된다.  

**기본 키가 아닌 컬럼이 다른 컬럼을 결정하는 관계를 이행적 함수 종속(Transitive Functional Dependency)** 이라고 한다. 즉, 한 속성이 다른 속성을 결정하고, 그 속성이 또 다른 속성을 결정하는 관계를 의미한다.  
 이행적 함수 종속은 이상 현상을 일으키기 때문에 제거해주어야 한다.  

### 제 3정규형(3NF)
- 제2 정규형을 만족해야 한다.
- 이행적 함수 종속이 존재하지 않아야 한다.

이행적 함수 종속을 제거하는 방법도 테이블을 분리하는 것이고, 결정자(`member_id`)와 종속자(`member_name`)를 묶어 별도의 `member` 테이블로 분리하면 된다.  

```sql
-- 1. member 테이블 생성 (회원 정보)
CREATE TABLE member_3nf (
    member_id INT NOT NULL,
    member_name VARCHAR(50) NOT NULL,
    
    PRIMARY KEY (member_id)
);
-- 2. orders 테이블 생성 (주문 정보, member_name 제거)
CREATE TABLE orders_3nf (
    order_id INT NOT NULL,
    member_id INT NOT NULL,
    ordered_at DATETIME NOT NULL,
    
    PRIMARY KEY (order_id),
    FOREIGN KEY (member_id) REFERENCES member_3nf (member_id)
);
```

#### member_3nf

|member_id | member_name |
|:--|:--|
|1 | 션 |
|2 | 네이트 |

#### orders_3nf

| order_id | member_id | ordered_at            |
|:---------|:----------|:----------------------|
| 1001     | 1         | 2025-08-20 10:00:00   |
| 1002     | 2         | 2025-08-21 11:00:00   |
| 1003     | 1         | 2025-08-21 12:00:00   | 

`member_name`은 `member_3nf` 테이블에 한 번만 저장되며, 회원 이름의 수정은 `member_3nf` 테이블의 행 하나만 수정하면 된다. 이제 회원을 참조하는 모든 주문에서 변경된 이름 정보를 일관성 있게 조회할 수 있다.  

<br/>

### BCNF 정규형

BCNF는 제3 정규형을 조금 더 강화한 버전으로, '강한 제3 정규형'이라고도 불린다. 실무에서는 제3 정규형까지 만족하는 설계를 목표로 하는 경우가 많지만 BCNF를 이해하면 더 깊이있는 설계가 가능하다.  

#### BCNF(Boyce-Codd Normal Form)
- 테이블의 모든 결정자(Determinant)가 후보 키(Candidate Key)여야 한다.

<br/>

#### 용어 정리

- 결장자는 함수 종속 관계(X -> Y)에서 X에 해당하는, 다른 컬럼의 값을 결정하는 컬럼(또는 컬럼의 집합)을 의미한다.  
- 후보 키는 테이블의 행을 유일하게 식별할 수 있는 컬럼의 최소 집합이다.  
- 기본 키는 여러 후보 키 중하나를 선택한 것이다.  

제3 정규형이 기본 키가 아닌 컬럼들 사이의 종속 관계(이행적 종속)만 제거했다면, BCNF는 기본키가 아니더라도 어떤 컬럼이 다른 컬럼을 결정한다면, 그 결정자는 반드시 후보키여야 한다는 규칙이다. 제3 정규형을 만족하면 BCNF를 만족하지만 드물게 만족하지 않는 경우가 있다.  

<br/>

### BCNF가 필요한 이유: 제3 정규형의 한계

BCNF는 실무에서 자주 발생하지 않지만, 전통적인 학교 수강 신청 예시로 설명한다.

1. 한 학생은 여러 개의 특강을 신청할 수 있다.
2. 하나의 특강은 여러 명의 교수가 가르칠 수 있다. (예: '데이터베이스' 특강을 김 교수, 박 교수가 함께 진행)
3. **한 교수는 오직 하나의 특강만 담당한다.** (이 규칙이 BCNF 위반을 만드는 핵심이다

| student_id | lecture_name | professor_name |
|:--|:--|:--|
| 101 | 데이터베이스 | 김교수 |
| 101 | 자바 | 서교수 |
| 102 | 데이터베이스 | 박교수 |
| 103 | 자바 | 서교수 |

#### 함수 종속성 분석
- 학생 ID와 특강 이름을 알면 담당 교수를 알 수 있다.  
- 교수 이름을 알면 그가 담당하는 특강 이름을 알 수 있다. (규칙 3번) 

#### 후보 키 분석
- `{student_id, lecture_name}`은 모든 컬럼을 결정하므로 후보 키가 될 수 있다.
- `{student_id, professor_name}`도 특강 이름을 알 수 있으므로 후보 키가 될 수 있다.
- 여기서는 `{student_id, lecture_name}`를 PK로 선택했다고 가정한다.  

#### 정규형 만족 여부 확인
- 제1, 제2 정규형은 만족한다.
- 테이블에 기본키가 아닌 컬럼은 `professor_name` 하나이므로, 이행적 함수 종속이 발생할 수 없다. 제3 정규형도 만족한다.
- BCNF는 만족하지 않는다. 
  - `{student_id, lecture_name}`는 교수 이름을 결정하므로, 이 결정자는 기본 키이미로 후보 키다.
  - `professor_name`은 `lecture_name`을 결정하지만 행을 유일하게 식별할 수 없기 때문에 후보키가 아니다. 따라서 BCNF를 위반한다.

#### BCNF를 위반했을 때의 문제점

제3 정규형까지 만족했지만, `professor_name` 이 `lecture_name` 을 결정하는 종속성 때문에 여
전히 데이터 이상 현상이 발생한다.   

- 수정 이상: '서교수'가 담당하는 특강이 발생한다면, '서교수'가 등장하는 모든 행을 변경해야 한다. 누락이 발생하면 데이터 불일치 문제가 발생한다.
- 삽입 이상: '최교수'가 새로운 특강을 개설해도 신청 학생이 없다면 PK인 `student_id`는 NULL일 수 없기 떄문에 테이블에 등록될 수 없다.
- 삭제 이상: 102번 학생이 '데이터베이스' 수강을 취소하여 행이 삭제되면 '박교수'의 담당하는 특장 정보는 데이터베이스에서 완전 삭제가 되어버린다.  

#### BCNF 적용: 테이블 분리

BCNF를 만족시키는 해결책은 정규화와 같이, 문제가 되는 함수 종속성을 기준으로 테이블을 분리하는 것이다. 문제가 되는 종속성은 `professor_name → lecture_name` 이다.  

| professor_name | lecture_name |
|:---------------|:-------------|
| 김교수           | 데이터베이스    |
| 박교수           | 데이터베이스    |
| 서교수           | 자바          |

| student_id | professor_name |
|:-----------|:---------------|
| 101        | 김교수           |
| 101        | 서교수           |
| 102        | 박교수           |
| 103        | 서교수           |

<br/>

### 실무와 정규화

#### 정규화를 사용하는 이유

- 데이터 중복 최소화: 불필요한 데이터 중복을 제거하여 저장 공간을 효율적으로 사용한다.
- 데이터 일관성 및 무결성 확보: 데이터가 여러 곳에 중복 저장되지 않으므로, 수정 시 발생할 수 있는 데이터 불일 치 간으성을 원천적으로 차단한다.
- 데이터 이상 현상(Anomaly) 해결: 삽입, 수정, 삭제 이상을 방지해 데이터 신뢰성을 높인다.
- 유연한 데이터 구조: 새로운 데이터 요구사항이 발생했을 떄, 테이블 구조 변경을 최소화하며 시스템을 확장할 수 있게 한다.

#### 정규화의 필요성

우리의 직관적인 사고방식은 데이터 정규화의 목표와 매우 유사하다. 우리는 현실 세계의 사물이나 개념을 인식할 때, 자연스럽게 다음 원칙을 적용한다.
- 하나의 칸에는 하나의 정보만
- 하나의 주제는 하나의 묶음으로
- 반복되는 정보는 한 곳에서만 관리

정규화를 배우는 이유는 정규화는 우리의 직관이 맞았는지 검증할 수 있는 체계적인 도구를 제공한다. 또한, BCNF 예시처럼 우리의 직관만으로 파악하기 어려운 복잡한 데이터 종속 관계를 발견하고 해결할 수 있는 이론적 기반이 되어준다. 즉, 우리의 '감'을 '논리'로 바꾸어 주는 과정이다.

#### 실무의 정규화

**개념을 중심으로 데이터를 모델링하는 사고방식** 자체가 이미 정규화의 원칙을 내포하고 있다. 전문가에게 정규
화 이론은 매번 따라야 하는 규칙 목록이라기보다는, 자신의 직관적인 설계가 논리적으로 탄탄한지 검증하고, 다른 개발
자들과 명확하게 소통하기 위한 **언어이자 도구**에 가깝다

실무에서보는 보통 제3 정규형 또는 BCNF까지 정규화를 진행하는 것을 목표로 한다. 정규화를 하면 테이블이 잘개 쪼개지기 때문에 `JOIN`을 해야하는 경우가 많아져 조회 성능 저하를 유발할 수 있다.  
읽기 작업이 빈버낳고 성능이 아주 중요한 일부 시스템에서는, 데이터 중복을 감수하고 `JOIN`의 수를 줄이기 위해 의도적으로 정규화 원칙을 위배하는 역정규화(Denormalization)을 수행하기 도 한다.

<br/>

