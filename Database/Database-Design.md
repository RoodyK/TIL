# 데이터베이스 설계

## 데이터베이스 설계의 중요성

데이터베이스는 백엔드 개발에서 기반이 되는 매우 중요한 부분이다. 자바나 파이썬 같은 애플리케이션 코드는 프레임워크나 아키텍처 패턴 덕분에 기능 추가나 코드 리팩토링을 유연하게 처리할 수 있다. 하지만 데이터베이스 구조(스키마)는 바로 잡는데 많은 비용 및 시간이 필요하다. 그렇기 때문에 데이터베이스의 설계 기반을 제대로 잡아야 한다.  

<br/>

잘못된 데이터베이스 설계는 데이터 무결성을 훼손하여 데이터 중복 및 삽입, 수정, 삭제 이상현상을 일으킨다. 그리고 정규화되지 않은 데이터는 하나의 테이블에 많은 데이터가 모두 모여있어 성능을 저하시키고 유지보수의 비용을 증가시킨다.  

또한 개발 단계로 넘어간 후 설계를 수정하려면 이미 들어간 데이터들 및 수정이 매우 힘들어진다. 만약 애플리케이션을 배포 후 데이터베이스를 수정한다고 하면 이러한 문제는 더 커질 것이다. 이처럼 데이터베이스를 초반에 설계하는 것은 미래에 발생할 재앙을 막고 시스템의 수명을 늘리는 현명한 투자가 될 것이다.  

<br/>
<br/>

## 데이터베이스 설계의 3단계 - 개념, 논리, 물리

데이터베이스 설계의 각 단계를 자세히 확인하기 전에 요약해서 확인한다

- 개념적 설계는 비즈니스 요구 사항을 이해가고, 현실 세계에서 물리적으로 존재하거나 논리적인 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계이다. 이 단계에서는 NoSQL, RDBMS 등에 종속되지 않으며 비즈니스 전문가와 고객의 요구 사항을 분석하여 산출물인 ERD 같은 설계도를 만들어낸다.  
- 논리적 설계는 개념적 설계에서 만든 밑그림을, 사용하려는 관계형 데이터베이스의 원리에 맞게 구체적인 구조로 다듬는 단계다. 이 때 실제 사용하는 RDBMS를 산정하지 않기 때문에 종속되지는 않는다. 이 단계에서 데이터는 어떤 타입으로 할 것인지(숫자, 문자, 날짜 등)와 테이블의 정규화를 적용하고 속성, PK, FK 등을 명확하게 정의한다.  
- 물리적 설계는 논리적 설계에서 만든 테이블 스키마를 실제 사용할 RDBMS에 맞게 최적화하여 구현하는 단계이다. 실제 사용될 테이블의 컬럼의 데이터 타입을 정하고, 어떤 인덱스를 사용하면 좋을지 결정한다. 그리고 DDL을 통해 물리적인 테이블을 생성한다.  

<br/>
<br/>
<br/>

# 개념적 모델링 - 개념

데이터베이스 설계는 개념적 모델링부터 시작한다. 우리가 데이터베이스의 테이블을 바로 생성하지 않는것은 데이터베이스가 결국 '현실 세계의 비즈니스'를 반영하는 거울이기 때문에다. 개념적 모델링은 개발자, 기획자, 현업 담당자 등이 모여 기술적인 용어 대신에 모두가 이해할 수 있는 그림과 용어로 만들어야 할 것을 명확하게 하는 가장 중요한 단계이다.  

모델 설계는 요구 사항 분석에서 시작되며, 요구 사항을 분석해서 데이터 세상의 뼈대를 생성할 때 '명사'와 '동사'에 집중해야 하며, **명사**는 우리가 관리해야할 대상인 엔티티나 엔티티가 가지는 속성이 될 확률이 높으며, **동사**는 관계가 될 확률이 높다.  

<br/>
<br/>

## 엔티티 도출하기

개념적 모델링의 가장 기본적인 요소는 '엔티티(Entity)'다. 엔티티는 저장할 가치가 잇는 중요한 데이터를 가지며, 다른 것들과 식별될 수 있는 대상이다.  
여기서 명사가 엔티티가 된다고 했지만, '문법적인 명사' 만이 아니라 동사이어도 시스템이 정보를 저장하고 관리해야 할 대상은 엔티티가 될 수 있다.

'쇼핑몰 요구 사항'에서 우리는 '회원', '주문', '상품' 이라는 엔티티를 도출했으며, 이 엔티티 서로서로가 관계가 있음을 확인할 수 있다.  
- '회원'과 '주문' 사이에 관계가 있다. (누가 주문했는가?)
- '주문'과 '상품' 사이에 관계가 있다. (무엇을 주문했는가?)

<br/>
<br/>

## 엔티티란?

엔티티는 "우리가 데이터를 저장하고 관리해야 할 대상"으로, 구체적으로 "저장할만할 가치가 있는 정보를 여러 개 가지고 있으면서, 다른것과 명확이 구분되는 유무형의 모든 것"을 말한다.  

- **유형 엔티티**는 사람, 사물, 장소와 같이 물리적인 형태가 있는, 우리가 직접 만지거나 볼 수 있는 대상을 의미하며 회원, 직원, 상품, 책 등이 있다.  
- **무형 엔티티**는 물리적인 형태는 없지만, 개념적으로 존재하는 관리 대상을 의미하고 주로 어떤 '사건'이나 '개념'을 데이터로 관리할 때
나타내며 주문, 예약, 수강 신청, 계좌 등이 있다.  

### 엔티티의 특징

- 엔티티는 반드시 해당 업무에 필요하고 관리해야 하는 정보이고, 업무 프로세스에 의해 이용되어야 한다.
- 엔티티에 속하는 각각의 데이터는 서로 명확하게 구분할 수 있아여 한다. 회원의 아이디를 부여하는 것과 같으며, 이것이 나중에 '식별자(Identifier)' 또는 '기본 키(Primary Key)'가 된다.  
- 엔티티는 관리할 만할 가치가 있는 여러 정보인 속성(컬럼)들을 가진다. 단일 속성을 가진다면 엔티티가 아닌 다른 엔티티의 일부 속성일 것이다.
- 엔티티는 개념적인 틀이며, 틀에 만들어진 실제 데이터 하나하나를 인스턴스라고 한다. 엔티티는 이 인스턴스들의 집합니다. 
- 엔티티는 다른 엔티티와 서로 관계를 맺는다. 엔티티들의 관계를 파악하는 것이 데이터베이스 설계의 핵심이다.  

<br/>
<br/>

## 엔티티 분류1

데이터베이스 설계는 '회원', '상품', '주문'과 같은 데이터를 식별하는 것에서 시작하며, 이 데이터들은 성격이 다르므로 회원은 잘 변하지 않는 데이터지만, 주문은 매 순간 새롭게 쌓이며 폭발적으로 증가할 수 있다.  

이처럼 엔티티의 성격과 역할을 제대로 파악하고 구분하는 과정이 엔티티 분류다. 엔티티를 분류하는 주요 기준은 존재 형태, 생성 시점 및 역할, 존재 종속성(독립성)이다.

<br/>

### 존재 형태에 따른 분류: 유형, 개념, 사건 엔티티

엔티티를 식별하는 가장 직관적인 방법 중 하나는 엔티티가 나타내는 대상의 존재 형태를 기준으로 분류하는 것이다. 크게 유형 엔티티, 개념 엔티티, 사건 엔티티로 구분할 수 있다.

<br/> 

1\. 유형 엔티티  
물리적인 실체를 가지는 엔티티다. 이들은 현실 세계에 구체적으로 존재하므로 데이터 모델링에서 가장 먼저 식별되는 경향이 있다. 유형 엔티티는 상대적으로 안정적이며 지속적으로 활용되는 정보를 담는다. 예로는 사원, 학생, 고객, 상품, 차량 등이 있다.  

<br/> 

2\. 개념 엔티티  
물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티다. 눈으로 보이지 않기 때문에 유형 엔티티에 비해 식별하기가 다소 까다롭고, 비즈니스 프로세스에 대한 깊은 이해가 필요하다. 업무 규칙이나 제도, 분류 기준 등을 표현하며, 유형엔티티와 마찬가지로 비교적 안정적인 정보를 관리한다. 예로는 부서, 조직, 팀, 계좌, 과목, 학과 등이 있다.

<br/> 

3\. 사건 엔티티(이벤트 엔티티)  
업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티다. 특정 시점에 발생하며, 비즈니스 활동 결과를 기록하는 역할을 한다. 즉, 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 소스가 된다. 예로는 주문, 계약, 청구, 매출, 결제, 입금, 출금, 수강신청, 예약, 사고접수 등이 있다.

<br/> 

데이터 모델에 '주문', '결제', '예약' 같은 사건 엔티티가 가득하다면, 그 시스템은 매일매일의 거래를 기록하는 온라인 거래 장부와 같을 것이고, '고객', '상품', '직원' 같은 유형/개념 엔티티가 설계의 중심이라면, 여러 곳에서 상용될 기준 정보나 고객 명단을 관리하는 시스템일 가능성이 높다.

데이터의 성격과 증가 추이를 미리 파악하면 '주문' 같은 테이블을 설계할 때 인덱스를 미리 설계하거나, 데이터 파티셔닝 및 아카이빙을 미리 준비할 수 있다.  

<br/>
<br/>

### 역할 및 발생 시점에 따른 분류: 기본, 중심, 행위 엔티티

엔티티는 비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있다. 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화 한다.

<br/>

1\. 기본 엔티티(Fundamental/Key Entity)  
업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티다. '키 엔티티'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행하고, 다른 엔티티의 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가진다. 예로는 회원, 상품, 사원, 부서, 고객 등이 있다.  

<br/> 

2\. 중심 엔티티(Main/Center Entity)  
기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티다. 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많다. 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 한다. 예로는 주문, 계약, 청구, 매출 등이 있다.  

<br/> 

3\. 행위 엔티티(Action/Behavioral Entity)  
두 개 이상의 부모 엔티티(주로 기본 엔티티와 중심 엔티티)로부터 발생하며, 업무가 흘러가면서 생성되는 상세 정보를 기록하는 엔티티다. 내용이 자주 변경되거나 데이터양이 지속적으로 증가하는 특징을 가지며, 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많다. 예로는 주문 이력, 변경이력, 로그 등이 있다.  

<br/>

이 세 가지 분류는 '기본->중심->행위'로 업무가 흘러가는 순서와 데이터의 원인과 결과를 명확하게 보여준다.

<br/>

실무에서 중요한 것은 분류 용어들을 외우기보다는 본질을 이해하는 것이 중요하다. 
이 분류법은 **사고의 틀**을 제공하는 것이고, 용어 자체를 암기해서 사용하는 것이 목적이 아니라, 각 테이블이 가지는 데이터의 '본질'과 '성격'을 빠르고 정확하게 간파하는 훈련을 하는 것이다.

<br/>
<br/>

## 엔티티 분류2

### 강한 엔티티와 약한 엔티티

엔티티는 다른 엔티티와의 관계 속에서 자신의 존재 여부가 결정되는지에 따라 강한 엔티티와 약한 엔티티로 분류할 수 있다.  

1\. 강한 엔티티(Strong Entity)  
다른 어떤 엔티티의 존재 여부와 관계없이 독립적으로 존재할 수 있는 엔티티를 의미하며, 다른 엔티티에 의존하지 않는다. 자신을 유일하게 식별할 수 잇는 속성들의 집합인 기본 키를 가진다. 예로는 사원, 고객, 상품, 부서 등과 같은 독립적으로 관리되는 대부분의 엔티티가 있다.  

<br/>

2\. 약한 엔티티(Weak Entity)  
다른 엔티티('소유 엔티티' 또는 '식별 엔티티'로 부르는 강한 엔티티)가 존재하지 않으면 독립적으로 존재할 수 없는 존재 종속적인 엔티티다. 전통적인 방식에서 약한 엔티티는 소유 엔티티의 주식별자를 빌려와 자신의 속성과 결합하여 주식별자를 삼아 자신을 식별한다. 예로는 부양가족 등이 있다.

<br/>

강한 엔티티와 약한 엔티티를 구분하면, 예를 들어 부모 엔티티(사원) 정보가 없는 자식 데이터(부양가족), 즉 고아 데이터가 생겨나면 데이터베이스 정합성이 깨지고, 시스템이 신뢰를 잃게 된다. 이 때 약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장하며, 부모가 존재하지 않는 문제를 설계 단계에서 원천 차단할 수 있다.  
강한 엔티티와 약한 엔티티의 구분은 바로 이런 데이터 재앙을 **설계 단계에서부터 원천적으로 차단**하기 위해 존재한다.  

하지만 이런 정통방식을 최에는 잘 사용하지 않고, 더 유연하고 실용적인 비 식별 관계라는 방법을 주로 사용한다.

<br/>
<br/>

### 구조적 관계 표현을 위한 특수 엔티티

엔티티 간의 관계가 단순한 연결선을 넘어, 그 자체가 하나의 독립된 의미를 갖는 개념일 때가 있는데, 이러한 사건(Event)이나 분류(Classification)와 같은 복잡한 관계를 효과적으로 모델에 반영하기 위해 사용하는 것이 연관 엔티티와 슈퍼타입/서브타입 구조이다.  

<br/>

1\. 연관 엔티티(Associative Entity)  
두 개 이상의 엔티티 간에 발생하는 특정 사건, 행위 계약 등을 표현하기 위해 도출되는 엔티티이다. 즉, 관계 자체가 중요한 속성을 가져 하나의 독립된 실체(Entity)로 다뤄져야 할 때 사용된다.
연관 엔티티의 가장 중요한 존재 이유는 '관계'에 종속되는 속성을 저장하기 위함으로, 예를 들어 '학생'과 '과목'의 관계에서는 '성적'이나 '수강신청일' 같은 데이터가 발생하는데 이 데이터는 학생이나 과목의 것이 아닌 수강이라는 행위 차제에 속하는데, 이 수강을 표현한느 것이 연관 엔티티로, 연관 엔티티는 두 개 이상의 다른 엔티티 간에 존재하는 다대다(M:N) 관계를 해소한다.  

<br/>

2\. 슈퍼타입/서브타입 엔티티(Supertype/Subtype Entity)  
논리적으로 동일한 개념 그룹에 속하지만 일부 속성이나 관계에서 차이가 있는 엔티티들을 효과적으로 표현하기 위한 기법이다. 'Is - a' 관계를 모델링하며, 객체지향 프로그래밍의 상속 개념과 유사하다.  

<br/>
<br/>

## 엔티티의 세부 정보, 속성 정의

속성(Attribute)이란 엔티티가 가지는 구체적인 특성이나 정보다. '회원'이라는 엔티티가 있을 때 속성은 회원명, 이메일, 전화번호, 주소가 된다.  

식별자는 정의된 속성들 중에서 아주 특별한 역할을 하는 속성으로 엔티티의 인스턴스(row)를 다른 데이터와 유일하게 구별해주는 이름표 역할을 한다. 데이터베이스의 기본 키가 된다.

<br/>
<br/>

## 카디널리티와 참여도

카디널리티와 참여도는 관계의 규칙을 정의하는 두 가지 핵심 요소이다.  

<br/>

### 관계의 수량, 카디널리티 분석

카디널리티는 한 엔티티의 인스턴스(row)가 다른 엔티티의 인스턴스와 몇 개나 관계를 맺을 수 있는지를 나타내는 수량 제약이다. 1:1, 1:N, 1:M, M:N 관계를 따지는 것이다.  

카디널리티는 엔티티 인스턴스(row) 하나가 다른 엔티티의 인스턴스와 맺을 수 있는 최대 숫자를 기준으로 표기한다.  
- 1(하나): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 최대 1개의 관계를 가질 수 있을 때 사용한다.
- N(하나 이상): 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 1개 이상, 즉 여러 개의 관계를 가질 수 있을 때 사용한다.  

<br/>

### 관계의 필수 여부, 참여도 분석

참여도는 한 엔티티의 인스턴스가 관계에 반드시 참여해야 하는지(필수), 아니면 참여하지 않을 수도 있는지(선택)를 결정한다.  

 개념적 모델링 단계는 RDBMS를 포함한 특정 기술에 종속되지 않기 때문에 외래키는 표함되지 않으며 엔티티간의 관계는 관계선으로 표한한다.  

<br/>
<br/>

## ERD

엔티티, 속성, 식별자, 관계, 카디널리티, 참여도를 하나의 그림으로 표현한 것이 ERD(Entity-Relationship Diagram)다.  

ERD를 그리는 방법은 '피터 챈 표기법'과 '까마귀발 표기법'이 있는데 주로 까마귀발 표기법이 사용된다. 까마귀발 표기법이 정보 밀도와 가독성이 좋고 표현이 직관적이다. 그리고 Dbeaver, ERDCloud 등 많은 데이터베이스 도구가 까마귀발 표기법을 기본으로 지원한다.  

<br/>
<br/>

## 다대다(M:N) 관계 해결

다대다 관계는 물리적으로 구현될 수 없으며, 관계에 속한 데이터를 저장할 장소가 없다. 이 문제를 해결하기 위해서는 다대다 관계를 연관 엔티티로 바꾸어 해결해야 한다.  

<br/>
<br/>

## 용어 사전

프로젝트의 모든 이해 관계자들은 같은 비즈니스 용어를 사용하는 것이 중요하다.  
개념적, 논리적 모델링 단계에서는 비즈니스 담당자들과 원활한 소통을 위해 한글 용어를 사용하는 경우가 많으며, 물리적 모델링 단계에서는 이 한글 용어들을 정한 규칙에 따라 영어로 정확하게 변환해야 하는데 이 때 **용어 사전**을 만들어 관리하면 편리하다.  

용어 사전은 많은 개발자들과 협업에서 서로 다른 변수명, 함수명, 테이블명 등의 용어를 사용할 때 공통으로 사용되는 용어를 정리해서 혼란없이 진행할 수 있는 '프로젝트 용어의 헌법'과 같다.  

단순히 단어를 나열하는 것을 넘어, 실무에서는 보다 체계적이고 상세한 용어 사전을 사용하며, 용어를 역할별로 분류하고, 약어와 전체 영문명을 명확히 구분하며, 실제 시스템에서 어떻게 사용되는지 구체적인 예시를 함꼐 기록하는 것이 좋다.  

용어 사전은 프로젝트가 진행됨에 따라 지속적으로 업데이트해서 최신 상태를 유지하고, 팀원 모두가 쉽게 접근 및 편집할 수 있는 도구를 사용해서 관리해야 한다.  

<br/>
<br/>

# 개념적 모델링 - 실전

프로젝트를 시작하고 요구 사항읋 분석해서 설계를 시작할 때 시작부터 전체 기능을 준비하고 기간을 잡으면 시작부터 삐걱거릴 수 있다.  

기능을 설계할 때는 필수적인 핵심 기능 및 지금 당장 필요한 기능부터 설계를 시작하면 개발 기간을 단축시키고, 이후에 차근차근 필요한 기능을 추가하면서 서비스를 오픈하는 것이 좋다. 

노련하고 숙련된 개발자와 기획자는 프로젝트를 잘개 쪼개서 지금 당장 필요하거나 필요하지 않은 것들을 분리할 줄 알아야 한다.

<br/>
<br/>

## 개념적 모델링 - 설계 시작

### 1단계: 핵심 요구 사항 다시 정의하기 (MVP)

핵심 요구 사항을 다시 정의하는 이 과정을 MVP(Minimum Viable Product, 최소 기능 제품) 라고 한다.  

복잡한 기능인 외부 판매자 기능, 쿠폰, 리뷰, 장바구니 기능같은 2차 기능은 미루고 1차 기능(핵심 기능)을 위주로 구현하고 나중에 2차 기능을 추가 개발한다.  

**쇼핑몰 MVP 기능 명세서**  
- 회원: 고객이 가입하고 자신의 정보를 관리할 수 있어야 한다.
- 상품: 우리가 판매할 상품을 등록하고 관리할 수 있어야 한다.
- 주문: 회원이 상품을 구매할 수 있어야 한다.
- 결제: 주문에 대한 결제 정보를 기록하고 관리할 수 있어야 한다.
- 배송: '결제가 완료된' 주문의 배송 상태를 관리할 수 있어야 한다.

<br/>

### 2단계: 핵심 엔티티 도출

핵심 기능을 추려서 단순해진 요구 사항에서 엔티티를 찾는다.   

도출된 핵심 엔티티: `회원` , `상품` , `주문` , `결제` , `배송`

<br/>

### 3단계: 속성 정의 및 관계 설정

- `회원(Member)`: 회원id, 로그인id, 비밀번호, 회원명, 이메일, 주소
- `상품(Product)`: 상품id, 상품명, 상품 가격, 재고 수량
- `주문(Order)`: 주문id, 주문 상태, 배송지 주소, 주문 일시
- `결제(Payment)`: 결제id, 결제 수단, 결제 금액, 결제 상태, 결제 일시
- `배송(Delivery)`: 배송id, 배송 상태, 운송장 번호  

<br/>

엔티티 관계 확인
- 회원은 여러 번 주문할 수 있다.(1:N)
- 하나의 주문에 대해서 하나의 결제가 이루어진다.(1:1)
- 하나의 주문에 대해서 하나의 배송이 이루어진다.(1:1)
- 하나의 주문에는 여러 상품이 포함될 수 있고, 하나의 상품은 여러 주문에 포함될 수 있다.(M:N)  

<br/>

### 4단계: M:N관계 해소와 '연관 엔티티'

M:N 관계는 물리적으로 구현할 수 없기 때문에 연관 엔티티를 도입해야 한다. 우리는 '주문' 엔티티와 '상품' 엔티티 사이에 '주문 항목'이라는 연관 엔티티를 도입한다.  

## 개념적 모델링 - ERD 작성

ERD 설계도를 만들기 위한 툴은 `draw.io`를 사용한다.  

![shopping mall erd](/Database/images/01-erd.png)

개념적 모델링의 목표는 모든 속성을 나타내는 것이 아닌 기획, 개발 등 모든 사람들의 이해를 돕는 것이 목표로, 핵심적인 것을 나타내고 등록일, 수정일과 같은 거의 모든 엔티티에 들어가는 속성은 생략했다.

개념점 모델링에서는 특정 데이터베이스에 종속되지 않기 때문에 외래키를 표현하지 않았지만, 실무에서는 보통 관계형 데이터베이스를 사용하기 때문에 개념적 모델링과 논리적 모델링을 함께 처리하는 경우 외래키를 표시하기도 하며, 보통 개발자 이외의 기획자들도 외래키가 있다고 해서 이해를 어렵게하지는 않는다.  

<br/>
<br/>
<br/>

# 논리적 모델링

논리적 모델링은 개념적 모델링에서 만든 청사진을 관계형 데이터베이스 구조에 맞게 변호나하는 과정이다. 엔티티는 **테이블**로, 속성은 **컬럼**으로 바꾸고, 각 테이블의 **기본 키(Primary Key)** 와 테이블 간의 관계를 표현하는 **외래 키(Foreign Key)** 등을 정의한다.

<br/>

## 키의 중요성

논리적 모델링은 특정 RDBMS에 종속되지 않는 순수한 데이터 구조를 설꼐하며, 가장 중요하게 다루어야 할 것이 '키(Key)'다.  

키는 데이터베이스 테이블의 각 행(Row)을 유일하게 식별할 수 있는 장치다. 키는 데이터를 찾는 용도 뿐만 아니라 테이블과 테이블을 연결해 관계를 맺어주고, 데이터 중복 및 잘못 입력되는 것을 막는 무결성 제약조건의 역할도 수행한다.  

<br/>

### 키(Key)

키는 테이블에 있는 각각의 행을 고유하게 식별할 수 잇는 하나 이상의 컬럼 집합이다.

#### **기본키(Primary Key - PK)**  
- 테이블의 모든 행을 유일하게 식별하는 대표 키다.
  - NULL 값을 가질 수 없다.(NOT NULL)
  - 반드시 유일해야 한다.(UNIQUE)
  - 값이 변하지 않아야 한다.(불변성)

#### **후보키(Candidate Key)**
- 기본 키가 될 수 있는 후보들을 말하며, 유일성과 최소성을 모두 만족하는 키를 말한다. 
  - 유일성(Unique): 모든 행을 서로 구분할 수 있어야 한다.
  - 최소성(Minimality): 행을 유일하게 식별하는 데 꼭 필요한 최소한의 컬럼만 포함해야 한다.

#### **대체 키(Alternate Key)**
- 후보 키 중에서 기본 키로 선택되지 않은 나머지 키들을 말한다.
- 회원 테이블에서 `member_id`가 기본 키로 선택됐다면, 유니크한 값으로 설정된 `email`, `phone`과 같은 속성은 대체 키가 된다.  

#### **외래 키(Foreign Key - FK)
- 테이블간의 관계를 연결하는 역할을 하는 중요한 키다.
- 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하는 것이다.

<br/>

## 자연 키 vs 대리 키

모든 테이블에서는 각 행을 식별하는 기본 키(PK)가 반드시 필요한 데, 기본 키를 찾는 과정에서 두 가지 후보인 자연 키와 대리 키를 만나게 된다.

### 자연 키

자연 키(Natural Key)란 우리의 비즈니스 로직 안에서 자연스럽게 발생하는, 의미를 가진 데이터를 기본 키로 사용하는 것을 말한다. `회원`의 이메일, `도서`의 ISBN 등이 자연키가 될 수 있다.  

자연키는 직관적이고, 비즈니스 규칙상 고유해야 하는 값을 PK로 지정하므로 중복 방지가 되지만, **변경 가능성**이 있다는 치명적인 단점이 있다.  

현대 데이터베이스 설꼐의 가장 중요한 원칙 중 하나는 "PK의 불변성"인데, 비즈니스 로직에 종속되는 자연 키는 이 원칙을 지키기 힘들다.  

<br/>

#### 문제 1 - 참조 무결성

회원 테이블(이메일, 이름, ...)과 주문 테이블(이메일, 주문 시간, ...)이 있을 때 주문 테이블은 회원 테이블의 이메일을 FK로 참조할 때 회원 테이블의 이메일이 변경될 수 있다면, 주문 테이블이 참조하던 회원 테이블의 이메일은 참조 무결성을 위배하게 된다.

#### 문제 2 - 연쇄 업데이트

문제 1에서 그렇다면 "양쪽 모두를 업데이트 하면 되는 것 아닌가?"라는 생각을 할 수 있는데, 실무에서 테이블이 매우 많을 것인데 이러한 연쇄 업데이트는 데이터베이스 서버의 엄청난 부하를 주게 된다.  

#### 문제 3 - 데이터 역사성 훼손

PK를 변경하게 되면 이전에 갖고 있었던 PK값의 로그가 모두 최신의 것으로 변경되어 데이터 역사성을 훼손하게 된다.  

#### 문제 4 - 외부 시스템과의 연동 문제

`member@old.com` 회원의 주문 정보를 외부 배송 시스템에 전달해서 배송 상태를 추적하고 있는데, 회원 정보가 `member@new.com`으로 변경되면, 우리 시스템과 와부 배송 시스템간의 동기화가 깨진다. 고객이 반품을 요청하거나 환불을 요청했을 때 배송 시스템과 우리 시스템상의 데이터가 일치하지 않아 오류가 발생하게 된다.  

<br/>

우리가 변경되지 않을 것이라고 생각하는 주민등록번호도 나라에 요청해서 변경될 수 있다.

<br/>

### 대리 키

자연키가 가진 '변경 가능성'이라는 치명적인 문제를 해결하기 위한 것이 대리 키(Surrogate Key)다. 인조 키(Artificial Key)라고도 한다.  

대리 키의 핵심은 비즈니스 로직과 완전히 무관한, 오직 데이터를 식별하기 위한 용도로만 존재하는, 임의의 값을 기본 키로 사용하는 것이다. UUID나 순차적으로 증가하는 1, 2, 3 ... 과 같은 값이 있다. 보통 `AUTO_INCREMENT`로 순차적인 값일 만들어서 사용한다.  

`member_id`를 `AUTO_INCREMENT`를 사용한 순차적으로 저장되는 대리 키 값을 PK로 사용할 때, 이 값은 비즈니스 로직과 연관이 없기 때문에, 이메일, 이름 등을 변경해도 절대 변하지 않는다. 이처럼 비즈니스 로직의 유연성을 확보할 수 있다.  

<br/>

### 자연 키의 올바른 사용

자연 키는 이제 PK를 대리 키에 넘기고, 비즈니스적으로 고유해야 하는 모든 컬럼에 `UNIQUE` 제약조건을 설정하면 된다.  

PK를 대리 키로 사용하고 `email`을 `UNIQUE`로 설정하면 다음 이점을 얻을 수 있다.
- 관계의 안정성: 불변의 대리 키가 모든 외래 키 관계의 중심을 잡아준다.
- 데이터 무결성: `UNIQUE` 제약 조건이 `email` 중복을 데이터베이스 차원에서 방지한다.
- 조회 성능: `UNIQUE` 제약조건을 설정하면 인덱스가 자동 생성되므로 `email`을 통한 조회 성능도 보장된다.  

<br/>

**현재 데이터베이스 설꼐에서 이처럼 대리 키를 사용한 PK 설정이 사실상 표준 방식이다.**

<br/>

## 자연 키 vs 대리 키 - 성능 트레이드 오프

### 자연 키 사용의 장점

비즈니스 요구사항을 봤을 때 자연 키(ex. `email`)만으로 데이터를 조회하는 경우가 대부분이라면, 조인 없이 해당 테이블에서 바로 원하는 정보를 얻을 수 있다. 하지만 대리 키를 사용할 때는 조인을 통해 이메일을 찾아야 한다.  
이처럼 자연 키를 사용하면 조인을 생략할 수 있어서 조회 성능이 더 좋을 수 있다.  

<br/>

### 자연 키 사용의 단점

#### 단점 1 - 외래 키 크기

자연 키가 `VARCHAR(50)` 처럼 긴 문자열이라면 참조하는 모든 자식 테이블에서 이 긴 문자열 컬럼을 가지고 있어야 한다.
- 일반적으로 대리 키로 사용하는 `BIGINT`(8바이트)에 비해 많은 디스크 공간을 차지한다.
- 테이블과 인덱스의 크기가 커지면 메모리에 한 번에 올릴 수 있는 데이터 양이 줄어들고, 조인 연산 시 비교해야 할 데이터 크기가 커져 메모리, CPU 사용량도 커지며 서버 성능 저하로 이어진다.  

#### 단점 2 - 인덱스 단편화와 쓰기 성능 저하

`email`과 같은 자연 키는 알파벳 순이나 가입 순서와 무관하게 생성되는데, 이런 상황에서 데이터에비스는 정렬된 상태로 인덱스에 저장해야 하므로 기존 데이터 'a...', 'f...'으로 이루어진 것에 'b...' 데이터를 삽입하는 과정에서 인덱스 페이지를 내누는 페이지 분할(Page Split)이 빈번하게 발생된다. 페이지 분할은 새로운 페이지를 할당하고 기존 데이터를 옮기는 복잡하고 비용이 큰 작업이다.  
이 과정에서 인덱스 내부에 빈 공간이 많이 생기는 단편화(Fragmentation)가 심해지고, 이는 쓰기 성능을 저하시킨다.

<br/>

### 대리 키 사용의 장점

#### 장점 1 - 뛰어난 쓰기 성능

`AUTO_INCREMENT`나 `SEQUENCE`를 사용하는 대리 키는 항상 이전 값보다 큰 숫자를 순서대로 만들어낸다.  
이는 페이지 분할을 거의 일으키지 않아 인덱스 단편화 문제가 발생하지 않아 매우 빠르고 효율적인 쓰기 성능을 제공한다. MySQL의 InnoDB 엔진은 `AUTO_INCREMENT` 처럼 순서대로 생성되는 대리 키 방식에 최적화된 저장 성능을 제공한다.  

#### 장점 2 - 외래 키 크기 최소화

`BIGINT` 타입의 대리 키는 8바이트 고정 크기를 가지며, `VARCHAR(50)` 같은 가변 길이 문자열보다 훨씬 작고 효율적이다.

<br/>

### 대리 키 사용의 단점

#### 단점 1 - 추가 조인 발생

대리 키를 사용하면 특정 비즈니스 데이터를 얻기 위한 과정에서 추가 조인이 필요할 수 있다. 하지만 대부분의 경우 추가 조인으로 인한 약간의 성능 저하보다는 대리 키가 제공하는 다른 수많은 이점(쓰기 성능, 데이터 크기, 유연성)이 훨씬 크다.  

#### 단점 2 - 추가 인덱스 필요

대리 키를 PK로 사용한다는 것은, 원래 자연 키로 사용하려던 컬럼을 이제 일반 컬럼으로 관리하는 것이기 때문에, `email` 같은 자연 키의 조회 성능을 보장하고 중복 방지를 위해 UNIQUE 인덱스를 반드시 생성해야 한다. 이는 추가 공간을 사용하고 약간의 쓰기 성능 저하를 감수해야 한다.  
하지만 대리 키는 데이터 모델의 안정성, 유연성, 쓰기 성능의 더 큰 이점을 주기 때문에 대리 키를 PK로 사용한다.

<br/>

## 자연 키 vs 대리 키 - 현대적인 설계

현대적인 데이터베이스 설계에서는 **거의 모든 경우에 대리 키 사용을 강력히 권장한다.**  

자연 키는 비즈니스 로직과 데이터의 '신원(ID)'를 강결합 시키는데, 대리 키는 데이터의 신원(ID)를 비즈니스 로직으로부터 완전히 분리시켜 느신한 결합을 이루게 해준다. 이는 유언성과 안정성이 증가하게 된다.  

<br/>

## 복합 키

현실 세계의 데이터를 논리적으로 표현하려고 할 때 자연스러운 식별자인 자연 키(Natural Key)를 찾기 위해 노력하는데, 이 식별자가 항상 단일 컬럼으로는 표현되지 않는다.  

```sql
CREATE TABLE movie_reservation (
    movie_title VARCHAR(100) NOT NULL, -- 영화 제목
    screening_dt DATETIME NOT NULL, -- 상영 시작 시간
    seat_number VARCHAR(10) NOT NULL, -- 좌석 번호
    reserver_id BIGINT NOT NULL, -- 예매자 id
    
    -- 복합키: movie_title + screening_dt + seat_number를 기본 키로 설정
    PRIMARY KEY (movie_title, screening_dt, seat_number)
);
```
좌석 예매를 식별하기 위해서는 영화 제목, 상영 시작 시간, 좌석 번호라는 이 세가지 값이 필요하다. 복합 키를 사용하면 데이터베이스는 세 컬럼의 조합이 중복되어 삽입되는 것을 막아 데이터의 유일성을 보장한다.

<br/>

### 자연 키를 복합 키로 사용하는 예시에서 발견되는 문제점

복합 키는 자연 키 기반이므로 비즈니스 변화에 취약하다. 영화 제목의 오타로 변경해야 할 때 연관된 테이블 모두를 변경해야 한다. 즉, 변경 가능성으로 인한 불안정성이 있다.

다른 테이블에서 복합 키를 외래 키로 참조할 때, 모든 컬럼을 복제해야 하기때문에 복잡성이 증가한다.  

복합 키는 직관적이지 않으므로 단일 키처럼 `WHERE id = 1`과 같이 조회할 수 없어 쿼리가 길어지고 조인 시에도 `ON` 절에서 복합 키를 모두 비교해야 하기 때문에 오류 발생이 쉽다. 또한 ORM에서 복합 키를 다루려면 별도의 식별자 클래스를 만드는 등 추가적인 매핑 로직이 필요해 개발 복잡도가 증가한다.  
시스템이 성정해 '상영관 번호'같은 새로운 조건이 추가된다면 기본 키의 구성이 바뀌어야 하는데 테이블의 구조변경 및 연관된 모든 테이블이 변경되야 하므로 확장에 어려움이 생긴다. 

<br/>

### 복합 키로 발생하는 문제 해결

복합 키로 인한 문제들을 해결하기 위한 대안은 대리 키를 사용하는 것이다. 대리키는 비즈니스와 무관한 값을 사용하여 불변성을 보장하고, 하나의 컬럼만 사용하기 때문에 간단하다.  

```sql
-- 예매 테이블 (대리 키 사용)
    CREATE TABLE movie_reservation (
    reservation_id BIGINT NOT NULL AUTO_INCREMENT, -- 대리 키 PK
    movie_title VARCHAR(100) NOT NULL,
    screening_dt DATETIME NOT NULL,
    seat_number VARCHAR(10) NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    PRIMARY KEY (reservation_id),
        
    -- 자연 키 부분에 UNIQUE 제약으로 데이터 무결성 보장
    UNIQUE KEY uq_movie_reservation (movie_title, screening_dt, seat_number)
);
```
- `reservation_id`는 절대 변하지 않으므로, 비즈니스적 변경이 발생해도 안전하다.
- 다른 테이블에서 단일 컬럼(대리 키)만 참조해도 되므로, 외래 키의 참조가 단순해진다.
- 크기가 작고 타입이 일관된 `BIGINT`는 여러 컬럼이 조합된 복합키보다 인덱싱과 조인 연산에서 훨씬 빠르다.
- 물리적인 기본키의 책임과 비즈니스 식별자(UNIQUE KEY로 묶은 값)를 분리해서 모델이 더 명확하고 유연해진다.  

대리 키의 명백한 장점 덕분에 현대적인 데이터베이스 설계는 아래 조합이 사실상의 표준으로 자리잡았다.
- 기본 키(PK)는 대리 키를 사용한다.
- 비즈니스를 다루는 자연 키는 `UNIQUE` 제약조건으로 설정한다.

<br/>

### 다대다 관계와 복합 키

'주문', '상품' 다대다 관계를 해소하기 위한 연관 테이블 '주문항목'의 PK를 설정하는 방법
- `order_id`, `product_id`를 복합 PK로 설정한다.
- 대리 키를 PK로 사용하고, `order_id`, `product_id`는 UNIQUE 제약조건을 설정한다.  

다대다 관계에서 복합 키를 PK로 사용했을 때 무결성 보장 및 테이블 구조만 봐도 주문과 상품의 관계를 나타냄을 알 수 있다.  
하지만 PK가 너무 뚱뚱해지고, 다른 테이블에서 참조했을 때 복합 키를 참조해야 하는 확장성의 제약, ORM의 사용이 불편해지는 여러 단점이 있다.  

다대다 관계에서 대리 키를 PK로 사용하면 기본 키가 단순해지며, 비즈니스 제약은 UNIQUE로 설정해서 사용하면 된다. 대리 키는 다른 테이블에서 일관되게 참조 가능하므로 구조가 단순하고 명확해진다. 그리고 UNIQUE 제약조건으로 복합 키와 같은 역할 수행도 가능하며, ORM에서도 대리 키는 일반적인 엔티티처럼 편하게 사용할 수 있다. 
UNIQUE 인덱스가 별도로 생성되는 단점은 있지만 현대의 컴퓨터 성능은 높아져가고 있기 때문에 무시할 수 있는 수준이다.

결론적으로 현대적인 데이터베이스 설계에서는 다대다 관계를 위한 연관 테이블도 대리 키를 기본 키로 사용하는 것을 권장한다. 이 방법은 복합키의 데이터 정합성 보장이라는 장점 및 대리키의 단순성, 불변성, 확장성이라는 장점을 모두 취할 수 있다.  

<br/>
<br/>
<br/>

## 관계

관계의 2대 핵심 요소는 **카디널리티(Cardinality)**와 **참여도(Optionality)**로 이 두가지를 어떻게 조합하느냐에 따라 관계의 성격이 결정된다.
- 카디널리티: 한 테이블의 행이 다른 테이블의 행과 몇 개나 연결될 수 있는지를 나타낸다.(1:1, 1:N, N:1, M:N)
- 참여도: 한 테이블의 행이 관계를 맺고 있는 다른 테이블에 반드시 대응되는 행을 가져야 하는지(필수 참여), 갖지 않아도 되는지(선택 참여)를 나타낸다.

<br/>

## 참여도

참여도는 한 엔티티가 관계에 필수적으로 참여해야 하는지(Mandatory), 아니면 선택적으로 참여할 수 있는지(Optional)를 나타낸다.  

논리적 모델링에서 이 참여도는 외래 키(FK) 컬럼의 NULL 허용 여부로 구현된다. 하지만 이 제약조건만으로는 모든 비즈니스 규칙을 강제할 수 는 없다. 구현 방법과 한계를 확인한다.

<br/>

![팀-멤버 관계](/Database/images/02-relation.png)

회원은 팀에 소속될 수도 있고, 소속되지 않은 상태일 수도 있다. 테이블을 생성할 때 `team_id` 속성에 `NOT NULL` 조건을 사용하면 회원은 팀에 필수적으로 소속되야 한다.  

위 테이블에서 회원은 팀에 필수적으로 소속되게 강제하거나, 선택적으로 팀에 소속되게 할 수 있다. 하지만 팀이 회원을 가지지 않아도 된다거나, 한명 이상의 회원을 필수적으로 가져야 한다는 규칙은 강제할 수 없다.  
이는 연관 관계의 부모 테이블(제약을 걸 대상)에는 외래 키 컬럼이 존재하지 않기 때문이다.  

이런 문제를 해결하려면 애플리케이션 계층에서 로직으로 해결해야 한다. 팀을 생성할 때 회원을 같이 생성해서 팀을 지정하도록 해야 한다.  

<br/>

### ERD와 비즈니스 규칙의 중요성

데이터베이스 제약조건으로 구현하기 어렵다고 해서, ERD에 원래의 비즈니스 규칙을 표현하지 않으면 안된다.
- ERD: 데이터베이스의 물리적 제약을 넘어, 원래의 비즈니스 규칙을 그대로 표현해야 한다. '팀은 반드시 한명 이상의 회원을 가져야 한다'는 규칙이 잇다면, ERD는 이 관계가 명확히 그려져야 한다.
- 데이터베이스 DDL: ERD에 표현된 규칙 중, 데이터베이스가 제약조건으로 강제할 수 있는 부분까지만 구현한다.
- 애플리케이션 코드: DDL로 구현하지 못한 나머지 비즈니스 규칙을 책임지고 구현해서 데이터의 무결성을 환상한다.

<br/>

### 일대다(1:N) 다대일(N:1) 관계 - 외래 키 위치

일대다 또는 다대일 관계에서 외래 키는 항상 다(N)쪽에 위치해야 한다.  
외래 키를 다(N)쪽에 두어야 제1정규형의 원자성을 지킬 수 있으며, 유연하고 확장 가능한 테이블을 설계할 수 있다.

<br/>

### 일대다(1:N) 다대일(N:1) 관계 - 조인과 뻥튀기

다대일(N:1) 관계에서 조인을 할 때는 데이터가 뻥튀기 되지 않지만, 일대다(1:N) 관계에서 조인을 할 때는 데이터가 뻥튀기 될 수 있음을 유의해야 한다.  

<br/>