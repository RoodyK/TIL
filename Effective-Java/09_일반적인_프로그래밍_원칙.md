# 9장. 일반적인 프로그래밍 원칙

지역변수, 제어구조, 라이브러리, 데이터 타입, 리플렉션, 네이티브 메서드를 다루고, 마지막으로 최적화와 명명 규칙을 논한다.    
<br/>

## 아이템 57. 지역변수의 범위를 최소화하라

지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다.  

지역변수의 범위를 줄이는 가장 강력한 기법은 ‘가장 처음 쓰일 때 선언하기’다. 사용하려면 멀었는데, 미리 선언부터 해두면 코드가 어수선해져 가독성이 떨어진다.  

지역변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다.  

모든 지역변수는 선언과 동시에 초기화해야한다. 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.  

try-catch문은 예외다. 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화 해야한다.(그렇지 않으면 예외가 블록을 넘어 메서드에까지 전파된다.)  

변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다.  

반복문은 독특한 방식으로 변수 범위를 초기화 해준다.  

반복변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while문보다 for 문을 쓰는 편이 낫다.  

지역변수의 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.  
<br/>
<br/>
<br/>

## 아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라

for-each문의 정식 이름은 ‘향상된 for 문(enhanced for statement)’으로 반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔해지고 오류가 날 일이 없다.  

하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경쓰지 않아도 된다.  
<br/>

```java
// 향상된 for 문 사용방법
for (Element e : elements) {
		...
}
```
<br/>
<br/>

### for-each문을 사용할 수 없는 상황

**파괴적인 필터링(destructive filtering)**: 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.  

자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.   
<br/>

**변형(transforming)**: 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.  
<br/>

**병렬 반복(parallel iteration)**: 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.  

for-each 문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.
<br/>
<br/>

### 핵심 정리

전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해준다. 성능 저하도 없다. 가능한 모든 곳에서 for문이 아닌 for-each문을 사용하자.  
<br/>
<br/>
<br/>

## 아이템 59. 라이브러리를 익히고 사용하라

### 표준 라이브러리를 사용할 때의 이점

1) 라이브러리 코드를 작성한 전문가의 지식과 자신보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.  

자바 7부터는 Random을 사용하는 것보다는 ThreadLocalRandom으로 대체하면 더 코품질의 무작위 수를 생성할 뿐만아니라 속도도 더 빠르다.  
<br/>

2) 핵심적인 일과 크게 관련없는 문제를 해결하느라 시간을 허비하지 않아도 된다.  
<br/>

3) 따로 노력하지 않아도 성능이 지속해서 개선된다. 사용자가 많고, 업계 표준벤치마크를 사용해 성능을 확인하기 때문에 표준 라이브러리 제작자들은 더 나은 방법을 꾸준히 모색할 수 밖에없다.  
<br/>

4) 기능이 점점 많아진다. 라이브러리에 부족한 부분이 있다면 개발자 커뮤니티에서 이야기가 나오고 논의된 후 다음 릴리스에 기능이 추가되곤 한다.  
<br/>

5) 자신이 작성한 코드가 많은 사람에게 낯익은 코드가 된다.  
<br/>

이점들을 볼 때 표준 라이브러리 기능을 사용하는 것이 좋아 보이지만, 실상 많은 프로그래머가 직접 구현해서 쓰는 이유는 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다.  

메이저 릴리스마다 주목할만한 수많은 기능이 라이브러리에 추가되는데 이 때 웹 페이지에 공시되는 새로운 기능을 한번쯤은 읽어볼만 하다.  

라이브러리는 매우 방대하여 모든 API 문서를 공부하기는 벅차지만 자바 프로그래머라면 적어도 `java.lang, java.util, java.io` 와 그 하위 패키지들에는 익숙해져야 한다.  

따로 언급할만한 라이브러리는 **컬렉션 프레임워크**와 **스트림 라이브러리**다. `java.util.concurrent`의 동시성 기능도 알아두면 도움이 된다.  
<br/>
<br/>

### 핵심 정리

아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리 가 있다면 쓰면 된다.  

있는지 잘 모르겠다면 찾아봐라. 일반적으로 라이브러리 코드는 자신이 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다. 

독자의 실력을 폄하하는 것이 아닌 코드 품질에도 규모의 경제가 적용된다. 즉, 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.  
<br/>
<br/>
<br/>

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라

float와 double 타입은 과학과 공학 계산용으로 설계되었다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 ‘근사치’로 계산하도록 세심하게 설계되었다. 따라서 정확한 결과가 필요할 때는 사용하면 안된다.  

float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다. 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.  
<br/>
<br/>

### 핵심 정리

정확한 답이 필요한 계산에는 float나 double을 피하라.  

소스점 추적은 시스템에 맡기고, 코딩 시의 불편함이나 성능 저하를 신경쓰지 않겠다면 BigDecimal을 사용하라.  

BigDecimal이 제공하는 여덟가지 반올림 모드를 이용하여 반올림을 완벽히 제어할 수 있다.  

법으로 정해진 반올림을 수행해야 하는 비즈니스 계산에서 아주 편리한 기능이다.  

반면, 성능이 중요하고 소수점을 직접 추적할 수 있을 때 숫자가 9자리 십진수로 표현할 수 있다면 int, 열 여덟자리 십진수로 표현할 수 있다면 long을 사용하라. 그 외는 BigDecimal을 사용해야 한다.  
<br/>
<br/>
<br/>

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

기본 타입에 대응하는 참조 타입을 박싱된 기본 타입이라 한다.  
<br/>
<br/>

### 기본타입과 박싱된 기본 타입의 차이

- 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다. 두 인스턴스는 값이 같아도 다르다고 식별될 수 있다.
- 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값(null)을 가질 수 있다.
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.  
<br/>

박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다. Comparator을 사용하자.  

기본 타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.  
<br/>
<br/>
<br/>

### 핵심 정리

기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.  

기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자.  

오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없에주지는 않는다.  

두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 독자가 원한게 아닐 가능성이 크다.  

같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullpointerException을 던질 수 있다.  

마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용이 나올 수 있다.  
<br/>
<br/>
<br/>

## 아이템 62. 타입이 적절하다면 문자열 사용을 피하라

문자열은 텍스트를 표현하도록 설계되었다.  

문자열은 다른 값 타입을 대신하기에 적합하지 않다. 보통 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용하는데, 입력받을 데이터가 진짜 문자열일 때만 사용하는 것이 좋다.  

문자열은 열거 타입을 대신하기에 적합하지 않다.  

문자열은 혼합 타입을 대신하기에 적합하지 않다.  

문자열은 권한을 표현하기에 적합하지 않다.  
<br/>
<br/>

### 핵심 정리

더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라.  

문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다. 문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.  
<br/>
<br/>
<br/>

## 아이템 63. 문자열 연결은 느리니 주의하라

문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.  

문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야하므로 성능 저하는 피할 수 없는 결과이다.  

성능을 포기하고 싶지 않다면 StringBuilder를 사용하자.
<br/>
<br/>

### 핵심 정리

성능에 신경써야 한다면 많은 문자열을 연결할 때는 문자열 연결 연산자(+)를 피하자. 대신 StringBuilder의 append 메서드를 사용하라. 

문자 배열을 사용하거나, 문자열을 하나씩 처리하는 방법도 있다.
<br/>
<br/>
<br/>

## 아이템 64. 객체는 인터페이스를 사용해 참조하라

적합한 인터페이스만 있다면 매개변수뿐만 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.  

객체의 실제 클래스를 사용해야 할 상황은 생성자로 생성할 때뿐이다.  
<br/>

```java
List<MyClass> list = new ArrayList<>();
```
<br/>

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질것이다.

나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자를 호출해주기만 하면 된다.  

주의할 점은 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.  

적합한 인터페이스가 없다면 클래스로 참조해야 한다. String과 BigInteger 같은 값 클래스가 예이다.  

적합한 인터페이스가 없는 두 번째 부류는 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이다. 

마지막은 인터페이스에서 없는 특별한 메서드를 제공하는 클래스들이다. PriorityQueue는 Queue 인터페이스에 없는 comparator 메서드를 제공한다.  

인터페이스를 참조하여 사용하면 더 유연하고 세련된 프로그램을 만들 수 있지만, 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.  
<br/>
<br/>
<br/>

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.  

Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.  

나아가 Constructor, Method, Field 인스턴스를 이용해 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있다. 
<br/>

단점도 존재한다.

- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 예외 검사도 마찬가지다. 프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려 시도하면 런타임 오류가 발생한다.
- 리플렉션을 이용하면 코드가 지저분해지고 장황해진다.
- 성능이 떨어진다. 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.  
<br/>

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.  

컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수 있을 것이다.  

이런 경우라면 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.  
<br/>

```java
// 리플렉션으로 생성하고 인터페이스로 참조해 활용한다.
public static void main(String[] args) {
    // 클래스 이름을 Class 객체로 변환
    Class<? extends Set<String>> cl = null;
    try {
        cl = (Class<? extends Set<String>>)  // 비검사 형변환!
                Class.forName(args[0]);
    } catch (ClassNotFoundException e) {
        fatalError("클래스를 찾을 수 없습니다.");
    }

    // 생성자를 얻는다.
    Constructor<? extends Set<String>> cons = null;
    try {
        cons = cl.getDeclaredConstructor();
    } catch (NoSuchMethodException e) {
        fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
    }

    // 집합의 인스턴스를 만든다.
    Set<String> s = null;
    try {
        s = cons.newInstance();
    } catch (IllegalAccessException e) {
        fatalError("생성자에 접근할 수 없습니다.");
    } catch (InstantiationException e) {
        fatalError("클래스를 인스턴스화할 수 없습니다.");
    } catch (InvocationTargetException e) {
        fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
    } catch (ClassCastException e) {
        fatalError("Set을 구현하지 않은 클래스입니다.");
    }

    // 생성한 집합을 사용한다.
    s.addAll(Arrays.asList(args).subList(1, args.length));
    System.out.println(s);
}

private static void fatalError(String msg) {
    System.err.println(msg);
    System.exit(1);
}

```
<br/>

위 코드에서 리플렉션의 단점 두 가지를 보여주는데, 첫 번째는 런타임에 총 여섯 가지나 되는 예외를 던질 수 있다.  

두 번째는 클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했다.
<br/>
<br/>

### 핵심 정리

리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만, 단점도 많다. 

컴파일타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야할 것이다. 단, 되도록 객체 생성에만 사용하고, 생성한 객체를 이용할 때는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해서 사용해야 한다.  
<br/>
<br/>
<br/>

## 아이템 66. 네이티브 메서드는 신중히 사용하라

자바 네이티브 인터페이스(Java Native Interface)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. 네이티브 메서드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.  
<br/>

네이티브 메서드의 주요 쓰임  

- 레지스트리 같은 플랫폼 특화 기능을 사용한다.
- 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 레거시 데이터를 사용하는 레거시 라이브러리가 그 예다.
- 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  
<br/>

플랫폼 특화 기능을 사용하려면 네이티브 메서드를 사용해야 한다. 하지만 자바가 성숙해가면서 (OS 같은) 하부 플랫폼의 기능들을 점차 흡수하고 있다. 그래서 네이티브 메서드를 사용할 필요가 계속 줄어들고 있다.  

자바 9부터 Process API를 추가해 OS에 접근하는 길을 열어주었다. 

성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.  

네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다. 그래서 정말로 고성능의 다중 정밀 연산이 필요한 자바 프로그래머라면 이제 네이티브 메서드를 통해 GML를 사용하는 걸 고려해도 좋다.  

네이티브 메서드에는 심각한 단점이 있다. 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더이상 안전하지 않다.  
<br/>
<br/>

### 핵심 정리

네이티브 메서드를 사용하려거든 한번 더 생각하라. 네이티브 메서드가 성능을 개선해주는 일은 많지 않다. 

저수준 자원이나 네이티브 라이브러리를 사용해야만 해서 어쩔 수 없더라도 네이티브 코드는 최소한만 사용하고 철저히 테스트하라. 

네이티브 코드안에 숨은 단 하나의 버그가 독자의 애플리케이션 전체를 훼손할 수 있다.  
<br/>
<br/>
<br/>

## 아이템 67. 최적화는 신중히 하라

마음 깊이 새겨야 할 최적화 격언 3가지  

> (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. (심지어 효율을 높이지도 못하면서) - 윌리엄 울프
> 

> (전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다. - 도널드 크누스
> 

> 최적화를 할 때는 다음 두 규칙을 따르라. 
> 첫 번째, 하지마라. 
> 두 번째, (전문가 한정)아직 하지마라. 다시말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라. - M. A. 잭슨
> 

<br/>

성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라. 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.  

프로그램을 완성할 때까지 성능 문제를 무시하라는 뜻이 아니다. 구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍처의 결함은 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다.  

성능을 제한하는 설계를 피하라. 환성 후 변경하기가 가장 어려운 설계 요소는바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.  

API를 설계할 때 성능에 주는 영향을 고려하라. public 타입을 가변으로 만들면(내부 데이터를 변경할 수 있게 만들면) 불필요한 방어적 복사를 수 없이 유발할 수 있다.  

잘 설계된 API는 성능도 좋은게 보통이다. 그러니 성능을 위해 API를 왜곡하는 건 매우 안좋은 생각이다.  

프로파일링 도구(profiling tool)는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다. 

이런 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여, 집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 한다.  
<br/>
<br/>

### 핵심 원리

빠른 프로그램을 작성하려 안달하지 말자. 

좋은 프로그램을 작성하다 보면 성능은 따라오기 마련이다. 

하지만 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 연두해 두어야 한다. 

시스템 구현을 완료했다면 이제 성능을 측정해보라. 충분히 빠르면 그것으로 끝이다. 

그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라. 가장 먼저 어떤 알고리즘을 사용했는지를 살펴보자. 

알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무리 해봐야 소용이 없다. 만족할 때까지 이 과정을 반복하고, 모든 변경 후에는 성능을 측정하라.  
<br/>
<br/>
<br/>

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라

자바의 명명 규칙은 크게 철자와 문법, 두 범주로 나뉜다.  

철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다. 이 규칙들은 특별한 이유가 없는 한 반드시 따라야 한다.  

패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓는다. 요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.  

패지키 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이뤄진다.  각 요소는 일반적으로 8자  이하의 짧은 단어로 한다.  

클래스와 인터페이스 이름은 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다. 여러 단어의 첫 글자만 딴 약자나 max, min 처럼 널리 통용되는 줄임말을 제외하고는 단어를 줄여쓰지 않도록 한다.  

메서드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같다.  

상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다.(VALUES, MAX_VALUES) 상수 필드는 불변인 static final을 말한다.  

지역변수에도 다른 멤버와 비슷한 명명 규칙이 적용된다. 단, 약어를 써도 좋다.  

타입 매개변수 이름은 보통 한 문자로 표현한다. 임의의 타입엔 T, 원소의 타입은 E, 맵의 키는 K, 값은 V, 예외에는 X, 메서드 반환 타입에는 R을 사용한다.  

객체를 생성할 수 있는 클래스의 이름은 보통 단수 명사나 명사구를 사용한다.  

객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓는다.  

인터페이스의 이름은 클래스와 같게 짓거나 보통 able, ible로 끝나는 형용사로 짓는다.  

애노테이션은 다양하게 활용되어 지배적인 규칙이 없다.  

어떤 동작을 수행하는 메서드의 이름은 동사나 동사구로 짓는다.  

반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓는다.  

객체의 타입을 바꿔서, 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType 형태로 짓는다.  

필드 이름에 관한 문법 규칙은 클래스, 인터페이스, 메서드 이름에 비해 덜 명확하고 덜 중요하다.  
<br/>
<br/>
<br/>
