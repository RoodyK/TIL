# 10장. 예외

예외를 제대로 활용하면 프로그램의 가독성, 신뢰성, 유지보스성이 높아지지만, 잘못 사용하면 반대의 효과만 나타난다.  
<br/>
<br/>

## 아이템 69. 예외는 진짜 예외 상황에만 사용하라

```java
// 반복문 예외의 잘못된 사용
try {
		int i = 0;
		while (true) {
				range[i++].climb();
		}
} catch (ArrayIndexOutOfBoundException e) {}

// 자바의 표준 관용구 사용
for (Mountain m : range) {
	m.climb();
}
```
<br/>

위의 코드만 봐도 예외를 잘못 사용하면 코드를 헷갈리게하고 성능도 좋지 않다. (저자는 2배차이가 남)  

예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.  

표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리쓴 기법은 자제하라. 
반면 과하게 영리한 기법에 숨겨진 미묘한 버그의 폐해와 어려워진 문제는 계속 이어질 것이다.  

잘 설계된 API라면 클라이언트가 정상적인 제어흐름에서 예외를 사용할 일이 없어야 한다. 특정 상태에서만 호출할 수 있는 ‘상태 의존적’ 메서드를 제공하는 클래스는 ‘상태 검사’ 메서드도 함께 제공해야 한다.  

Iterator 인터페이스의 next와 hasNext가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.  (for-each도 내부적으로 hasNext를 사용한다.)  
<br/>

상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침  

1) 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.  

2) 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.  

3) 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 확실히 들어낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어려울 것이다.  
<br/>
<br/>

### 핵심 정리

예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서든 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.  
<br/>
<br/>
<br/>

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

자바는 문제 상황을 알리는 타입(throwable)으로 검사(checked) 예외, 런타임(unchecked) 예외, 에러 세 가지를 제공한다.  

호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라. 검사와 비검사를 구분하는 기본 규칙이다.  

검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.  

비검사 throwable은 두 가지로, 런타임 예외와 에러다. 두 예외는 통상적으로 잡지 말아야 한다.  

프로그램에서 비검사 예외를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.  

프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.  

런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. 전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다.  

복구 가능하다고 믿는다면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하자. 확신하기 어렵다면 비검사 예외를 선택하는 편이 나을 것이다.  

에러는 보통 JVM 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다. Error 클래스를  상속해 하위 클래스를 만드는 일은 자제하기 바란다.  

독자들이 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다. throwable은 직접적으로 절대 사용하지 말자.  

검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다. 따라서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.  
<br/>
<br/>

### 핵심 정리

복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예오리르 던지자. 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자.

검사 예외라면 복구에 필요한 정볼르 알려주는 메서드도 제공하자.
<br/>
<br/>
<br/>

## 아이템 71. 필요 없는 검사 예외 사용은 피하라

검사 예외는 안정성을 높여주지만, 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.  

어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다. 어느쪽이든 API에 부담을 준다.  

더구나 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터는 부담이 더욱 커졌다.  

검사 예외가 프로그래머에게  지우는 부담은 메서드가 단 하나의 검사 예외를 던질 때가 특히 크다. 검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.  

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. 검사 예외를 던지는 대신 빈 옵셔널을 반환하면 된다. 단점은 예외 발생 이유를 알려주는 부가정보를 담을 수 없다는 것이다.  
<br/>
<br/>

### 핵심 정리

꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. 

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 

옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.  
<br/>
<br/>
<br/>

## 아이템 72. 표준 예외를 사용하라

표준 예외를 재사용하면 얻는게 많다.  

우리들의 API가 다른 사람이 익히고 사용하기 쉬워지고, 낯선 예외르 사용하지 안게 되어 읽기 쉽게 된다는 장점이 있다.  
<br/>
<br/>

### 가장 많이 사용되는 표준 예외

- IllegalArgumentException: 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외이다.
- IllegalStateException: 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다. (제대로 초기화되지 않은 객체 사용)
- NullPointerException: null을 허용하지 않는 메서드에 null을 건넸을 때 던진다.
- IndexOutOfBoundsException: 인덱스가 범위를 넘어섰을 때 던진다.
- ConcurrentModificationException: 단일 스레드에서 사용하려고 설꼐한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다. (외부 동기화 방식으로 사용하려고 설계한 객체도 마찬가지)
- UnsupportedOperationException: 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.  
<br/>

Exception, RuntimeException, Throwable, Error 직접 재사용하지 말자. 이 클래스들은 추상 클래스라고 생각해야 한다. 다른 예외들의 상위 클래스로, 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.  

상황이 부합할 때 항상 표준 예외를 재사용하자. 이 때 AP 문서를 참고해 그 예외가 어떤 상황에서 던져지는지 확인해야 한다. 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다. 더 많은 정보를 제공하기 원하면 표준 예외를 확장해도 좋다.  

인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을, 그렇지 않으면 IllegalArgumentException을 던지자.  
<br/>
<br/>

