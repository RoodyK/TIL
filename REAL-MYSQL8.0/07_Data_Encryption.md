# 데이터 암호화

5.7 버전은 데이터 파일(테이블 스페이스)에 대해서만 암호화 기능이 제공됐다.  
8.0 버전부터는 데이터 파일뿐만 아니라 리두 로그나 언두로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작됐다.  

애플리케이션의 암호화는 주로 중요 정보를 가진 컬럼 단위로 암호화를 수행하며,  데이터베이스 수준에서는 테이블 단위로 암호화를 적용한다.  

<br/>
<br/>

## MySQL 서버의 데이터 암호화

MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터를 읽고 쓰는 지점에서 암호화 또는 복호화를 수행한다. 즉, InnoDB 스토리지 엔진의 I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행된다.  
서버에서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요하지 않다.  

서버에서 사용자 쿼리를 처리하는 과정에서 데이터 암호화 여부를 식별할 필요가 없으며, 비암호화 테이블과 동일한 처리과정을 거친다.  
데이터 암호화 기능이 활성화돼 있다고 해도 MySQL 내부 사용자 입장에서는 아무런 차이가 없다고 느끼는 암호화 방식을 TDE(Transparent Data Encryption)이라고 한다.  
"Data at Rest Encryption"라고도 하는데 "Data at Rest"는 메모리나 네트워크 전송 단계까 아닌 디스크에 저장된 단계에서만 암호화된다는 의미로 사용된다.  

<br/>

### 2단계 키 관리

MySQL 서버의 TDE에서 암호화하는 키는 키링(KeyRing) 플러그인에 의해 관리된다.

- keyring_file File-Based 플러그인 (커뮤니티 사용 가능)
- keyring_encrypting_file Keyring 플러그인 (엔터프라이즈 에디션)
- keyring_okv KMIP 플로그인 (엔터프라이즈 에디션)
- keyring_aws Amazon Web Services Keyring 플러그인 (엔터프라이즈 에디션)  

플러그인들은 마스터 키 관리 방법만 다를 뿐 서버 내부적으로 작동하는 방식은 모두 동일하다.  
서버의 키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용한다.  

![encryption](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fy22Vi%2Fbtr0NJp9APe%2FmClAE4ibglQ2yOwyx0bw8K%2Fimg.png)  

MySQL 서버의 데이터 암호화는 마스터 키와 테이블스페이스 키라는 두 가지 종류의 키를 가지고 있는데, 테이블스페이스 키는 프라이빗 키라고도 한다.  
서버는 HashiCorp Vault 같은 외부 키 관리 솔루션(KMS, Key Management Service) 또는 디스크의 파일(keyring_file or keyring_encrypted_file플러그인 사용 시)에서 마스터 키를 가져오고, 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블 스페이스 키를 발급한다.  
그리고 MySQL 서버는 마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.  
생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않으며, 테이블스페이스 키는 절대 서버 외부로 노출되지 않기 때문에 테이블스페이스 키를 주기적으로 변경하지 않아도 보안상 취약점이 되지 않는다.  

```sql
-- 마스터 키는 외부의 파일을 이용하기 때문에 노출될 위험이 있므므로 주기적으로 변경해줘야 한다.
ALTER INSTANCE ROTATE INNODB MASTER KEY;
```

마스터 키를 변경하면 서버는 기존의 마스터 키를 이용해 각 테이블스페이스 키를 복호화한 후 새로운 마스터 키로 다시 암호화한다.  
마스터 키가 변경되는 동안 서버의 테이블 스페이스 키 자체와 데이터 파일의 데이터는 변경되지 않는다.  
서버에서 2단계 암호화를 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다.  
테이블 스페이스가 변경됐다면 서버는 데이터 파일의 모든 데이터를 다시 복호화하고 다시 암호화해야 한다. 이로 인해 키를 변경할때마다 많은 작업을 해야 하며, 사용자 쿼리를 처리하는 데도 영향을 미치게 된다.  

TDE에서 지원되는 암호화 알고리즘은 AES-256비트다. 테이블 스페이스키는 AES-256 ECB, 실제 데이터 파일은 AES-256 CBC로 암호화된다.  

<br/>

### 암호화의 성능

MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재된다.  
데이터 페이지가 한 번에 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보인다.  
하지만 쿼리가 InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 때문에 복호화 시간동안 쿼리 처리가 지연될 것이다.  
암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화해야하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸린다.  
하지만 데이터 페이지 저장은 사용자 쿼리를 처리하는 스레드가 아닌 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아니다.  
DQL, DML은 새롭게 디스크에서 읽어야하는 데이터 페이지의 개수에 따라서 복호화 지연이 발생한다.  

데이터 파일은 암호화 키보다 더 크기 때문에 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다.  
암호화한다고해서 InnoDB 버퍼 풀의 효울이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않는다.  

서버는 같은 테이블에 대해 암호화와 압축이 동시에 적용되면 압축을 먼저 실행 후 암호화를 적용한다.  

#### 압축이 먼저 실행되는 이유  
- 일반적으로 암호화된 결과문은 아주 랜덤한 바이트의 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨린다. 그래서 최대한 압축 효율을 높이기 위해 사용자의 데이터를 그대로 압축해서 용량을 최소화한 후 암호화를 적용한다.  
- 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재할 수 있다.  그래서 암호화가 먼저 실행되고 압축이 적용된다면 서버는 버퍼 풀에 존재하는 데이터 페이지에 대해서도 매번 암복호화 작업을 수행해야 한다.  

암호화된 테이블의 경우 읽기는 3~5배 정도 느리며, 쓰기의 경우 5~6배 정도 느린 것을 확인할 수 있다.(밀리초 단위로 체감이 크진 않음)  

<br/>

### 암호화와 복제

MySQL 서버의 복제에서 레플리카 서버는 소스 서버의 모든 사용자 데이터를 동기화하기 때문에 실제 데이터 파일도 동일할 것이라고 생각할 수 있다.  
TDE를 이용한 암호화 사용 시 서버에서 기본적으로 모든 노드는 각자의 마스터 키를 할당해야한다. 데이터베이스 서버의 로컬 디렉토리에 마스터 키를 관리하느 ㄴ경우에는 소스 서버와 레플리카 서버가 다른 키를 가질 수 밖에 없겠지만 원격으로 키 관리 솔루션을 사용하는 경우에도 소스 서버와 레플리카 서버는 서로 다른 마스터 키를 갖도록 설정해야 한다.  
마스터 키가 레플리카로 복제되지 않기 때문에 테이블스페이스 키 또한 레플리카로 복제되지 않는다.  
소스 서버 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리하기 때문에 복제 멤버들의 데이터 파일은 암호화되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라진다.  

```sql
-- 복제 소스 서버의 마스터 키 변경
ALTER INSTANCE ROTATE INNODB MASTER KEY
```

마스터 키 로테이션을 실해앟면 소스 서버와 레플리카 서버 각각 서로 다른 마스터 키를 새로 발급받는다.  
MySQL 서버의 백업에서 TDE의 키링 파일을 백헙하지 않는 경우가 있는데, 이 경우 키링 파일을 찾지 못하면 데이터를 복구할 수 없게 된다.  
키링 파일을 데이터 백업과 별도로 백업한다면 마스터 키 로테이션 명령으로 TDE의 마스터 키가 언제 변경됐는지까지 기억하고 있어야 한다.  

<br/>

## Keyring_file 플러그인 설치

커뮤니티 에디션은 keyring_file 플러그인만 사용 가능하다.  
keyring_file 플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리하는데, 이 때 마스터 키는 평문으로 디스크에 저장된다.  
즉, 마스터 키가 저장된 파일이 외부에 노출된다면 데이터 암호화는 무용지물이 된다.  

마스터 키를 보관하려면 키링 파일을 다른 서버로부터 다운로드해서 로컬 디스크에 저장한 후 MySQL 서버를 시작하는 방법을 고려해보는 것도 좋다.  

TDE 플러그인의 경우 MySQL 서버가 시작되는 단계에서도 가장 빨리 초기화돼야 한다.  
my.cnf 설정 파일에 early-plugin-load 시스템 변수에 keyring_file 플러그인을 위한 라이브러리 ("keyring_file.so")를 명시하면 된다.  
마스터 키를 저장할 키링 파일의 경로를 keyring_file_data 설정에 명시하면 된다.  
이 경로는 하나의 MySQL 서버만 참조해야 한다.  


```bash
[mysqld]
# 키링 파일 라이브러리
early-plugin-load = keyring_file.so
# 저장될 경로
keyring_file_data = /opt/homebrew/etc/keyring/tde_master.key
```

플러그인 확인 

```sql
SHOW PLUGINS
```

데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실ㅇ행하면 키링 파일의 마스터 키가 초기화된다.  
`ls -alth tde_master.key`  
`ALTER INSTANCE ROTATE INNODB MASTER KEY`

<br/>
<br/>

## 테이블 암호화

키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일하다.  

<br/>

### 테이블 생성

```sql
CREATE TABLE tab_encrypted (
    id INT,
    data VARCHAR(100),
    PRIMARY KEY(id),
) ENCRYPTION='Y;

INSERT INTO tab_encrypted VALUES (1, 'test_data');
```

`ENCRYPTION='Y`로 설정하면 데이터가 디스크에 기록될 때는 데이터가 자동으로 암호화되어 저장되고, 다시 디스크에서 메모리로 읽어올 때 복호화된다.  


```sql
-- 암호화된 테이블 검색
SELECT table_schema, table_name, create_options
FROM information_schema.tables
WHERE table_name = 'tab_encrypted';
```

테이블마다 ENCRYPTION 옵션을 설정하지 않고 서버의 모든 테이블에 암호화를 적용하려면 `default_table_encryption` 시스템 변수를 ON으로 설정하면 된다.  

<br/>

### 응용 프로그램 암호화와의 비교

애플리케이션에서 암호화해서 MySQL 서버에 저장하는 경우도 있는데, 이경우 저장되는 컬럼의 값이 이미 암호화된 것인지 여부를 MySQL 서버는 인지하지 못한다.  그래서 애플리케이션에서 암호화된 컬럼은 인덱스를 생성해도 기능을 100% 활용할 수 없다.  

애플리케이션에서 암호화된 값으로 저장된 값을 조회해서 정렬하면 이미 암호화 된 값을 정렬하기 때문에 암호화 전의 데이터로 정렬할 수 없지만, MySQL 서버의 TDE 암호화 기능을 사용하면 인덱스 관련 작업을 모두 처리한 후 디스크에 데이터 페이지를 저장할 때만 암호화하기 때문에 제약이 없다.  

애플리케이션 암호화와 MySQL 서버의 암호화 기능 중 선택해야 하는 상황이라면 MySQL 서버의 암호화 기능을 선택할 것을 권장한다.  

MySQL 서버의 TDE 기능으로 암호화하면 모든 암호화 데이터를 평문으로 확인할 수 있다.  
애플리케이션에서의 암호화 기능은 평문의 내용을 확인할 수 없다.  
애픒리케이션의 암호화 기능은 서비스의 요관거 성능을 고려해서 선택해야 하고, MySQL 서버의 암호화 기능과 혼합해서 사용하면 더 안전한 서비스를 구축할 수 있을 것이다.  

<br/>

### 테이블 스페이스 이동

서버의 DBA면 테이블스페이스만 이동하는 기능을 자주 사용할 것이다.  
테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동(Export & Import) 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠르다.  

TDE가 적용되 암호화된 테이블의 경우 원본 서버와 목적지 서버의 암호화 키(마스터 키)가 다르기 때문에 원본 서버에서 `FLUSH TABLES` 명령으로 테이블스페이스를 익스포트 할 수 있다.  

```sql
FLUSH TABLES source_table FOR EXPORT
```

#### 암호화되지 않은 테이블 스페이스 복사과정  

암호화되지 않은 테이블에 대해 위의 명령이 실행되면 MySQL 서버는 source_table의 저장되지 않은 변경 사항을 모두 디스크로 기록하고, 더이상 source_table에 접근할 수 없게 잠금을 건다. 그와 동시에 source_table의 구조를 source_table.cfg 파일로 기록해둔다.  
그러면 source_table.ibd 파일과 source_table.cfg 파일을 목적지 서버로 복사한다.  
복사가 모두 완료되면 UNLOCK TABLES 명령을 실행해 source_table을 사용할 수 있게 하면 된다.  

#### 암호화된 테이블의 복사 과정
암호화된 테이블에 대해 위의 명령이 실행되면 MySQL 서버는 임시로 사용할 마스터 키를 발급해서 source_table.cfp라는 파일로 기록한다.  
그리고 암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일의 헤더 부분에 저장한다.  
그래서 암호화된 테이블의 경우 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 임시 마스터 키가 저장된 *.cfp 파일을 함께 복사해야 한다.  
*.cfg 파일은 단순히 테이블의 구조만 가지고 있기 때문에 파일이 없어져도 경고만 발생하고 테이블스페이스를 복구할 수 있지만 *.cfp 파일이 없어지면 복구가 불가능해진다.  

<br/>
<br/>

## 언두 로그 및 리두 로그 암호화

테이블의 암호화를 적용하더라도 디스크로 저장되는 데이터만 암호화되고 MySQL 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리되며, 이 평문 데이터가 테이블의 데이터 파일 이외의 디스크 파일로 기록되는 경우에는 여전히 평문으로 저장된다.  
그래서 테이블 암호화를 적용해도 리두 로그나 언두 로그, 그리고 복제를 위한 바이너리 로그에는 평문으로 저장하는 것이다.  

8.0.16 버전부터 `innodb_undo_log_encrypt`, `innodb_redo_log_encrypt` 시스템 변수를 통해서 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됐다.  

테이블의 암호화는 테이블 하나에 암호화가 적용되면 모든 데이터가 암호화되지만, 리두 로그와 언두 로그는 그렇게 적용할 수 없다.  
리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그나 언두 로그만 암호화해서 저장한다.  
반대로 리두 로그와 언두 로그가 암호화 되는 상태에서 암호화를 비활성화하면 그때부터 로그를 평문으로 저장한다.  

리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화하고, 테이블스페이스 키는 다시 마스터 키로 암호화 한다.  
`ALTER INSTANCE ROTATE INNODB MASTER KEY` 명령이 실행되면 새로운 마스터 키가 발급되고 테이블 암호화에 사용된 테이블스페이스 키와 동일하게 그 새로운 마스터 키에 의해 다시 암호화 된다.  
로그 데이터 암호화에 테이블 스페이스 키가 사용된다고 했는데 이는 실제 테이블 암호화에 사용된 테이블 스페이스 키가 아니라 리두 로그와 언두 로그를 위한 각각의 프라이빗 키가 발급되고, 해당 프라이빗 키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장되는 것이다.  

```sql
-- 리두 로그 암호화 확인
SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';

SET GLOBAL innodb_redo_log_encrypt=ON;
INSERT INTO ...
```

<br/>
<br/>

## 바이너리 로그 암호화

테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문을 저장한다.  
리두, 언두 로그처럼 일정 시간의 데이터가아닌 바이너리 로그는 의도적으로 상당히 긴 시간동안 보관하는 서비스도 있고 때로는 증분 백업(Incremental Backup)을 위해 바이너리 로그를 보관하기도 한다.  
이런 이유로 바이너리 로그 파일의 암호화는 상황에 따라 중요도가 높아질 수도 있다.  

바이너리 로그와 릴레이 로그 파일 암호하 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고, MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지는 않는다.   

<br/>

### 바이너리 로그 암호화 키 관리

![binaryLog](https://blog.kakaocdn.net/dn/bbEwGx/btrW0PAVgit/CKMaNR6yvHP8Fp3FxbSREk/img.png)  

바이너리 로그와 릴레이 로그 파일의 데이터 파일 키(File Key)로 암호화해서 디스크로 저장하고, 파일 키는 "바이너리 로그 암호화 키"로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더데 저장된다.  
즉, "바이너리 로그 암호화 키"는 테이블 암호화의 마스터 키와 동일한 역할을 하며, 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용된다.  

<br/>

### 바이너리 로그 암호화 키 변경

```sql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

#### 바이너리 로그 암호화키 변경 과정  
1. 증가된 시퀀스 번호화 함계 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장(비암호화 로그 파일 무시)
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거  

4번 작업은 상당히 시간이 걸리는데, 이를 위해 키링 파일에서 "바이너리 로그 암호화 키"는 내부적으로 버전(시퀀스 번호) 관리가 이뤄진다.  
이는 이전 암호화 키를 순차적으로 가지는 것이다.  
모든 바이너리 로그와 릴레이 로그 파일의 파일 키가 새로운 바이너리 로그 암호화 키로 암호화되어 저장되면 기존 바이너리 로그 암호화 키는 필요하지 않으므로 키링 파일에서 제거된다.  

```sql
-- 바이너리 로그 파일 암호화 여부 확인
SHOW BINARY LOGS;
```

<br/>