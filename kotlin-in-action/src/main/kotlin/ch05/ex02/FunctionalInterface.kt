package ch05.ex02

/**
 * 코틀린 람다는 자바 API와 호환된다.
 *
 * 자바에서는 인터페이스 안에 추상 메서드가 하나인 함수형 인터페이스(단일 추상 메서드 인터페이스)를 람다로 사용할 수 있다.
 * 코틀린에서도 똑같이 사용 가능하다.
 *
 * 명시적으로 객체를 선언하면 매번 호출할 때마다 새 인스턴스가 생긴다.
 * postponeComputation(1000, object: Runnable {
 *     override fun run() {
 *         println(22)
 *     }
 * })
 *
 * 람다를 사용하면 자신이 정의된 함수의 변수에 접근하지 않는다면 (람다 정의가 들어있는) 함수가 호출될 때마다 람다에 해당하는 익명 객체가 재사용된다.
 * postponeComputation(1000, { println(22) })
 */
fun postponeComputation(delay: Int, run: Runnable) {}

/**
 * 람다가 자신을 둘러싼 환경의 변수를 캡처하면 더 이상 각각의 함수 호출에 같은 인스턴스를 재사용할 수 없다.
 * 이런 경우 컴파일러는 호출마다 새로운 인스턴스를 만들고, 그 객체 안에 챕처한 변수를 저장한다.
 *
 * 람다에 대한 익명 클래스와 그 클래스의 인스턴스를 생성하는 것에 대한 논의는
 * 함수형 인터페이스를 받는 자바 메서드에 대해서는 성립하지만 코틀린 확장 함수를 사용하는 컬렉션어 대해서는 성립하지 않는다.
 *
 * 람다를 inline 표시가 돼 있는 코틀린 함수에 전달하면 익명 클래스가 생성되지 않는다.
 * 람다를 함수형 인터페이스 인스턴스로 변환하는 과정은 자동으로 일어나는데, 명시적으로 변환을 수행해야 하는 경우가 있다.
 */
fun handleComputation(id: String) { // 호출마다 새 인스턴스 생성
    postponeComputation(1000, {
        println(id)
    })
}


/**
 * SAM 생성자는 컴파일러가 생성한 함수로 람다를 단일 추상 메서드 인터페이스의 인스턴스로 명시적으로 변환해준다.
 * 이를 컴파일러가 변환을 자동으로 수행하지 못하는 맥락에서 사용할 수 있다.
 * 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 함수가 있다면 람다를 직접 반환할 수 없고, SAM 생성자로 감싸야 한다.
 *
 * SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
 * SAM 생성자는 하나의 인자(함수형 인터페이스의 유일한 추상 메서드 본문에 사용할 람다)만을 받아 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.
 */
fun createAllDoneRunnable(): Runnable { // 값을 반환하기 위해 SAM 생성자 사용
    return Runnable { println("All done!") }
}

/**
 * 값을 반환할 때 외에 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장해야 하는 경우에도 SAM 생성자를 사용할 수 있다.
 * 여러 버튼에 같은 리스너를 적용하고 싶다면 리스트로 람다를 SAM 생성자를 통해 함수형 인터페이스 인스턴스로 만들어 변수에 저장해 활용할 수 있다.
 *
 * // SAM 생성자를 사용해 listener 인스턴스 재사용
 * val button1 = Button("")
 * val button2 = Button("")
 * val listener = OnClickListener { view ->
 *     val text = when (view.id) {
 *         button1.id -> ""
 *         button2.id -> ""
 *         else -> ""
 *     }
 * }
 *
 * 람다에는 익명 객체와 달리 this가 없다. 람다를 변환한 익명 클래스의 인스턴스를 참조할 방법이 없다.
 * 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다. 그런 경우 람다 대신 익명 객체를 사용해 리스너를 구현한다.
 * 익명 객체는 this가 익명 객체 인스턴스 자신을 가리킨다.
 */

fun main() {
    // 명시적으로 객체를 선언하면 매번 호출할 때마다 새 인스턴스가 생긴다.
    postponeComputation(1000, object: Runnable {
        override fun run() {
            println(22)
        }
    })

    // 람다를 사용하면 자신이 정의된 함수의 변수에 접근하지 않는다면 (람다 정의가 들어있는) 함수가 호출될 때마다 람다에 해당하는 익명 객체가 재사용된다.
    postponeComputation(1000, { println(22) })

    createAllDoneRunnable().run()
}