package ch08.ex01

/**
 * Int, Boolean, Any 등의 기본 타입을 확인한다.
 * 코틀린은 자바와 달리 원시 타입과 래퍼 타입을 구분하지 않는다. 그 이유와 기본 타입의 래핑을 확인한다.
 *
 * 자바는 원시 타입과 참조 타입을 구분하며, 원시 타입에는 그 값이 직접 들어가지만, 참조 타입은 메모리상의 객체 위치가 들어간다.
 *
 * 원시 타입은 효율적으로 저장하고 여기저기 전달 가능하지만, 값에 대해 메서드를 호출하거나 컬렉션에 사용 불가하다. 자바는 이를 위해 래퍼 타입으로 원시 타입 값을 감싸서 사용한다.
 * 코틀린은 원시 타입과 래퍼 타입을 구분하지 않고 항상 같은 타입을 사용한다.
 *
 * 래퍼 타입을 구분하지 않으면 편리하다. 숫자 타입 등 원시 타입의 값에 대해 메서드를 호출할 수 있다.
 */
fun showProgress(progress: Int) {
    val percent = progress.coerceIn(0, 100) // 객체 값이 해당 범위에 있으면 그 값을 반환하고 없으면 최대 값을 반환
    println("We're $percent % done!")
}

/**
 * 원시 타입과 참조 타입이 같을 때 항상 객체로 표현하면 비효율적인데, 코틀린은 그러지 않는다.
 * 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방법으로 표현된다. 대부분(변수, 프로퍼티, 파라미터, 반환 값 등)의 경우는 Int 타입은 자바 int 타입으로 컴파일 된다.
 * 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우 뿐이다.
 *
 * 코틀린의 타입
 * - 정수 타입: Byte, Short, Int, Long
 * - 부동소수점 숫자 타입: Float, Double
 * - 문자 타입: Char
 * - 불리언 타입: Boolean
 */

/**
 * 양수를 표현하기 위해 모든 비트 범위를 사용하고 싶을 때가 있다.
 * - 비트와 바이트 수준에서 작업을 수행
 * - 비트맵 픽셀을 조작
 * - 파일에 담긴 바이트들이나 다른 2진 데이터를 다룰 때
 * 이런 경우 코틀린은 JVM의 일반적인 원시 타입을 확장해 부호 없는 타입을 제공한다.
 *
 * 코틀린의 4가지 부호 없는 타입
 * 타입       | 크기    | 값 범위
 * UByte 타입 | 8비트   | 0~255
 * UShort    | 16비트  | 0~65536
 * UInt      | 32비트  | 0~2^32 - 1
 * ULong     | 64비트  | 0~2^64 - 1
 *
 * 부호 없는 숫자 타입들은 상응하는 부호 있는 타입의 범위를 '시프트'해서 같은 크기의 메모리를 사용해 더 큰 양수 범위를 표현할 수 있게 해준다.
 *
 * 코틀린의 부호 없는 수도 필요할 때만 래핑된다. 그렇지 않은 경우 원시 타입의 성능 특성을 그대로 지닌다.
 * 음수가 필요하지 않을 때 부호 없는 정수를 사용하는 것이 아닌, 명시적으로 전체 비트 범위가 필요한 경우가 아니라면 보통의 정수를 사용하고 함수에서 음수인지 검사하는 것이 좋다.
 *
 * 부호없는 숫자 타입: 구현 세부 사항
 * JVM은 부호 없는 수에 대한 원시 타입을 지정하거나 제공하지 않는다. 코틀린은 이를 바꿀 수 없으므로 기존 부호가 있는 원시 타입 위에 자체적인 추상화를 제공한다.
 * 4.5절의 인라인 클래스를 통해 이런 추상화를 제공한다.
 * 부호 없는 값을 표현하는 각 클래스는 실제로는 인라인 클래스이며, 각 인라인 클래스는 기억 장소로 자신에 상용하는 부호 있는 타입을 사용한다.
 * 내부에서 UInt는 실제로 Int다. 코틀린 컴파일러가 인라인 클래스를 기저의 프로퍼티로 대신하거나 래핑 등의 처리를 해주므로 부호 없는 숫자 타입이 부호 있는 타입과 같은 성능으로 작동한다.
 *
 * 코틀린 컴파일러는 쉽게 Int 같은 타입을 그에 상응하는 JVM 원시 타입으로 쉽게 변환할 수 있다. 두 타입이 서로 같은 값들을 표현할 수 있기 때문이다.
 * 자바 원시 타입은 null이 될 수 없으므로, 코틀린에서 사용할 때도 널이 될 수 없는 타입으로 취급할 수 있다.
 */

/**
 * null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 코틀린에서 널이 될 수 있는 원시 타입을 사용하면, 자바의 래퍼 타입으로 컴파일 된다.
 *
 * 널 가능성이 있는 변수는 널 검사를 먼저 하고 값을 다뤄야 한다.
 * 코틀린에서는 원시 타입 래퍼 클래스가 없기 때문에 변수나 프로퍼티에 널이 들어갈 수 있는지만 고민하면 된다.
 *
 * 제네릭 클래스의 경우 래퍼 타입을 사용한다. 어떤 클래스의 타입 인자로 원시 타입을 넘기면 코틀린은 그 타입에 대한 박스 타입을 사용한다.
 * JVM은 타입 인자로 원시 타입을 허용하지 않기 때문에, 자바나 코틀린 모두 래퍼 타입을 사용해야 한다.
 */
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
        if (age == null || other.age == null) {
            return null
        }
        return age > other.age
    }
}

/**
 * 코틀린과 자바의 가장 큰 차이점 중 하나는 수를 변환하는 바잇ㄱ이다.
 * 코틀린은 한타입의 수를 다른 타입으로 자동 변환하지 안흔ㄴ다. 결과 타입이 허용하는 수의 범위가 원래 타입의 범위보다 넓은 경우조차 자동 변환은 불가능하다.
 *
 * val i = 1
 * val l: Long = i => type mismatch 에러 발생
 *
 * 대신 직접 변환 메서드를 호출해야 한다.
 * val i = 1
 * val l: Long = i.toLong()
 *
 * 코틀린은 모든 원시 타입에 대해 toLong() 등 변환 함수를 제공한다.
 *
 * 코틀린은 개발자의 혼란을 피하고자 타입 변환을 명시하기로 결정했다. 특히 래퍼 타입을 비교하는 경우 문제가 많다. equals는 기본적으로 객체를 비교한다.
 * 참조 타입을 비교할 때 코틀린에서 타입을 명시적으로 변환해서 같은 타입의 값으로 만든 후 비교해야 한다.
 *
 * 숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다. 42L, 42.0f 처럼 상수 뒤에 타입을 표현하는 문자를 붙이려면 변환이 필요 없다.
 * 직접 변환하지 않아도 숫자 리터럴을 타입이 알려진 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.
 *
 * 코틀린 산술 연산자에서도 자바와 똑같이 숫자 연산 시 오버플로나 언더플로가 발생할 수 있다. 코틀린은 이들을 검사하느로 추가 비용을 들이지 않는다.
 *
 * 코틀린은 문자열울 수로 변환할 때 NumberFormatException을 명시적으로 처리하기 귀찬흥ㄹ 때 ToIntOrNull(), toByteOrNull() 메서드 등 편의 함수를 사용할 수 있다.
 * toBoolean() 함수는 문자열을 불리언으로 변환한다.
 */
fun printALong(l: Long) = println("value: $l")

/**
 * 자바에서 Object가 클래스 계층 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.
 * 자바에셔는 원시 타입을 제외한 참조 타입만 Object의 계층에 포함된다. 코틀린에서는 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다.
 * 코틀린에서도 원시 타입 값을 any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다.(박싱)
 * val answer: Any = 42 => Any가 참조 타입이기 때문에 42가 박싱됨
 *
 * Any는 널이 될 수 없는 타입임을 유의하라. 코틀린에서 널을 포함하는 모든 값을 대입할 변수를 선언하려면 Any? 타입을 사용해야 한다.
 *
 * 내부에서 Any 타입은 java.lang.Object에 대응한다. 자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.(정확히는 널 여부를 알 수 없는 Any!)
 * 코틀린 함수가 Any를 사용하면 자바 바이트코트의 Object로 컴파일 된다.
 *
 * toString, equals, hashCode 메서드는 Any에 정의된 메서드를 상속한 것이다. 그 외의 Object에 있는 다른 메서드는 Any에서 사용할 수 없다.
 * 메서드를 호출하려면 java.lang.Object 타입으로 값을 캐스팅 해야 한다.
 */

/**
 * 코틀린 Unit 타입은 자바 void와 같은 기능을 한다. 문법적으로 Unit은 반환 타입 없이 정의한 함수와 같다.
 *
 * 코틀린 함수의 반환 타입이 Unit이고 그 함수가 제네릭 함수를 오버라이드하지 않는다면 함수는 내부에서 자바 void 함수로 컴파일된다. 이 함수를 자바에서 오버라이드 하면 void 타입이 된다.
 */
fun f(): Unit = println("Unit!")

/**
 * 코틀린의 Unit과 자바 void의 차이점
 * - Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit 타입을 인자로 쓸 수 있다.
 * - Unit 타입에 속한 값은 단 하나뿐이며, 그 이름도 Unit이다.
 * - Unit 타입의 함수는 Unit 값을 암시적으로 반환한다.
 * 이 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 쓸모가 있다.
 *
 * 코틀린에서 Unit을 명시적으로 반환할 필요는 없으며, 컴파일러가 암시적으로 Unit을 넣어준다.
 *
 * 코틀린에서 Unit이라는 이름을 고른 이유는 전통적으로 Unit은 '단 하나의 인스턴스만 갖는 타입'을 의미해 왔고,
 * 그 유일한 인스턴스의 유무가 자바 void와 코틀린 UInit을 구분하는 가장 큰 차이다.
 *
 * 자바에서 사용하는 Void라는 이름을 사용할 수도 있겠지만, 코틀린에서는 Nothing이라는 전혀 다른 기능을 하는 타입이 하나 존재한다.
 */
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() = println("process logic...")
}

/**
 * Nothing: 이 함수는 결코 반환되지 않는다.
 * 코틀린에서는 결코 성공적으로 값을 돌려주는 일이 없으므로 '반환값'이라는 개념 자체가 의미가 없는 함수가 일부 존재한다.
 * 테스트 라이브러리들은 fail이라는 함수를 제공하는 경우가 많은데, fail은 특별한 메시지가 들어있는 예외를 던지면서 테스트를 실패시킨다.
 *
 * 이런 함수를 호출하는 코드를 분석하는 경우 함수가 정상적으로 끝나지 않는다는 사실을 알면 유용한데, 코틀린에서는 Nothing이라는 특별한 반환 타입이 있다.
 *
 * Nothing 타입은 아무 값도 포함하지 않는다. Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.
 * 그 외의 다른 용도로 사용하는 경우 Nothing 타입의 변수를 선언하더라도 그 변수에 아무 값도 저장할 수 없으므로 아무 의미도 없다.
 *
 * Nothing을 반환하는 함수를 엘비스 연산자의 오른쪽에 사용해서 전제조건을 검사할 수 있다.
 * val address = company.address ?: fail("No address")
 * println(address.city)
 *
 * 컴파일러는 Nothing이 반환 타입인 함수가 결코 정상 종료되지 않음을 알고 그 함수를 호출하는 코드를 분석할 때 사용한다.
 */
fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}

fun main() {
    showProgress(146)
    showProgress(90)

    println(Person("San", 35).isOlderThan(Person("Mike", 42)))
    println(Person("San", 35).isOlderThan(Person("John")))

    // 리터럴 변환
    val b: Byte = 1
    val l = b + 1L // + 는 Byte와 Long을 인자로 받을 수 있다.
    printALong(l)

    // 오버플로, 언더플로
    println(Int.MAX_VALUE + 1) // 오버플로로 인해 값이 양수 최댓값에서 음수 최솟값으로 넘어간다.
    println(Int.MIN_VALUE - 1) // 오버플로로 인해 값이 음수 최솟값에서 양수 최댓값으로 넘어간다.
}