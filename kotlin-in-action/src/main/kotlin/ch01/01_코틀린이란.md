# 코틀린이란 무엇이며, 왜 필요한가?

코틀린은 JetBrains에서 개발한 JVM과 그 외의 다른 플랫폼에서 돌아가는 현대 프로그래밍 언어이다. 코틀린은 범용 언어로 간결하고 안전하며 실용적이다.

코틀린은 '더 나은 자바'로 시작했다. 개발자들이 일반적으로 저지를 수 있는 유형의 오류를 방지하고, 현대적 언어 설계 패러다임을 포용하면서도 자바와 상호 호환이 가능하고, 간결한 문법으로 효율적으로 개발할 수 있게 설계됐다.  

<br/>
<br/>

## 코틀린의 주요 특성

코틀린은 정적 타입 지정 언어로 런타임이 아니라 컴파일 시점에 오류를 잡을 수 있다. 코틀린은 객체지향 언어와 함수형 언어의 아이디어를 조합해 우아한 코드를 작성하고, 강력한 추상화를 제공한다.  

### 코틀린의 용도

코틀린은 어느 하나를 다루는 것이 아닌 개발 과정에서 수행해야 하는 모든 과업에 있어 생산성을 향상시켜준다.  

- 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 서버상의 코드(백엔드)

코틀린의 주목적은 자바가 사용되고 있는 모든 용도에 적합하면서 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것이다.  
코틀린 다중 플랫폼을 사용하면, 데스크톱, iOS, 안드로이드, 브라우저에서도 코틀린을 실행할 수 있는 크로스플랫폼 애플리케이션을 만들 수 있다.  

<br/>

### 정적 타입 지정의 장점

정적 타입 지정의 핵심은 모든 식의 타입을 컴파일 시점에 알 수 있다는 것이다. 코틀린 컴파일러는 필드가 존재하지 않거나 함수의 반환 타입이 예상과 달라짐으로 인해 생기는 모든 종류의 버그를 컴파일 타임에 발견해 문제를 미리 방지할 수 있다.  

- 성능: 런타임에 어떤 메서드를 호출할지 살펴볼 필요가 없으므로 호출이 더 빠르다.
- 신뢰성: 컴파일러가 타입을 사용해 프로그램 일관성을 검증하며, 런타임에 프로그램의 실패 가능성을 줄인다.
- 유지 보수성: 코드가 작용하는 타입을 보며, 낯선 코드를 다룰 때도 더 쉽게 다룰 수 있다.
- 도구 지원: 정적 타입 지정으로 리팩터링의 신뢰도를 높이고, 코드 완성이나 IDE 기능의 정확도를 높일 수 있다.  

코틀린은 컴파일 시점에 모든 식의 타입이 알려져 있어야 하지만, 개발자가 변수 타입을 직접 명시할 필요는 없다. 이를 코틀린 컴파일러가 문맥을 보고 유추해준다.  

```kotlin
val x: Int = 1 // 명시적 지정
val y = 1 // 자동 추론
```

위 코드처럼 컴파일러가 문맥을 고려해 변수 타입을 결정하는 것을 **타입 추론(type inference**라 한다. 이로 인해 개발자가 타입을 선언하는 불편함이 사라진다.  

코틀린은 Nullable Type을 지원한다. 이를 통해 NullPointerException을 컴파일 시점에 검사해서 프로그램의 신뢰성을 높일 수 있다.  

<br/>

### 함수형 프로그래밍과 객체지향 프로그래밍의 조합

다중 패러다임 언어인 코틀린은 객체지향 접근 방시고가 함수형 스타일을 엮어 제공한다.

#### 함수평 프로그래밍의 핵심
- 일급 시민인 함수: 함수를 일반 값처럼 변수에 저장하고, 다른 함수의 인자로 전달하고, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
- 불변성: 내부 상태를 바꾸지 않는 불변 객체를 사용해 프로그래밍한다.
- 사이드 이펙트 없음: 입력이 같으면 항상 같은 출력을 하며, 다른 객체 상태를 변경하지 않고 함수 외부나 다른 바깥 환경과 상호작용 하지 않는 순수 함수를 사용한다.  
  

#### 함수형 스타일의 프로그램의 장점 
- 비슷한 작업을 하는 코드 조각을 함수로 뽑아내고 서로 다른 세부사항을 인자로 전달하는데, 이 인자 자체가 함수다. 코틀린은 이런 함수를 람다로 간결하게 표현할 수 있다.
- 멀티 스레드 프로그램에서 같은 데이터를 여러 스레드가 변경했을 때의 문제는 순수 함수를 사용하면 데이터 변경이 발생하지 않는다고 확신할 수 있으므로 안전하게 동시성 처리를 할 수 있다.
- 사이드 이펙트가 없는 함수를 통해 그 함수가 의존하는 전체 환경을 구축하기 위한 준비 코드 없이 독립적으로 테스트 가능하며, 외부와 상호작용하지 않으므로 코드를 쉽게 추론할 수 있어 테스트가 쉬워진다.    

#### 함수형 프로그래밍을 제공하는 코틀린의 특징
- 함수 타입을 지원하며 어떤 함수가 다른 함수를 파라미터로 받거나, 새로운 함수를 반환할 수 있다.
- 람다식을 지원하며 번거로운 준비 코드를 작성하지 않고 코드블록을 쉽게 정의하고 다른곳에 전달할 수 있다.
- 멤버 참조를 통해 함수를 값으로 사용할 수 있다. 
- 데이터 클래스는 불변적인 데이터를 저장하는 클래스를 만들 수 있는 간결한 구문을 제공한다.
- 코틀린은 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.  

코틀린으로 코드를 작성할 때 객체지향과 합수형 접근 방식을 조합해서 사용 가능하고, 인터페이스와 클래스 계층 구조를 바당으로 하는 프레임워크도 쉽게 사용할 수 있다.  

<br/>

### 코틀린은 동시성, 비동기 코드를 자연스럽고 구조적으로 사용한다

동시성 처리에는 스레드로부터 callback, future, promise, 반응형 확장 등의 다양한 접근 방법이 있었다.  

코틀린은 동시성과 비동기 프로그래밍의 문제를 코루틴이라는 일시 중단 가능한 계산(suspendable computation)을 사용해 접근한다. 코루틴에서는 코드가 자신의 실행을 잠시 중단시킬 수 있고, 나중에 중단 지점부터 작업을 계속 수행할 수 있다.  
코루틴은 가벼운 추상화로, 큰 성능 손해를 보지 않고 수백만 개의 동시성 작업을 시작할 수 있다.  

<br/>

### 코틀린은 오픈소스로 모든 목적에 사용할 수 있다

코틀린 언어와 컴파일러, 라이브러리 및 코틀린과 관련한 모든 도구는 모두 오픈소스이며, 어떤 목적에든 무료로 사용할 수 있다. 코틀린은 아파치2 라이선스하에 제공된다. 개발은 [깃허브](https://github.com/jetbrains/kotlin)를 통해 열린 방식으로 이뤄진다.  

<br/>
<br/>

## 코틀린이 자주 쓰이는 분야

주로 안드로이드 개발과 서버 개발에 사용된다.  

### 백엔드 지원: 코틀린 서버 프로그래밍

서버 프로그래밍 종류(더 많은 종류가 존재)
- 브라우저에 HTML 페이지를 돌려주는 웹 애플리케이션
- HTTP API로 모바일 애플리케이션에 JSON API를 제공하는 백엔드 애플리케이션
- RPC(원격 프로시저 호출) 프로토콜이나 메시지 버스를 통해 서로 통신하는 작은 서비스들로 이뤄진 마이크로서비스  

개발자들은 기존 프레임워크나 기술을 확장하고 개선해서 기존 시스템과 새로운 코드와 통합한다.  

코틀린은 자바 코드와 상호운용할 수 있다는 점이 장점이다. 자바 클래스를 코틀린으로 확장해도 문제가 없고, 코틀린 클래스 안의 메서드나 필드에 특정(자바) 애노테이션을 붙여야 하는 경우에도 문제가 없다.  

코틀린의 타입 시스템은 null 값을 정확히 추적하기 때문에 자바에서 NullPointerException가 발생할 코드가 컴파일에 실패하기 때문에 신뢰성이 좋아진다.  

스프링도 코틀린을 일급 시민으로 지원한다. 다른 코틀린 서버 프로임워크로는 케이토(Jetbrains에 의해 만들어짐)나 http4k 도 있다.  

케이토는 애플리케이션이 HTTP 요청을 라우팅하는 방법을 기술하는 커스텀 도메인 특화 언어(DSL)을 제공한다. DSL은 코틀린 언어 특성을 유연하게 조합해서 설정, 복잡한 객체 생성, 객체 관계 매핑(ORM) 작업, 객체를 데이터베이스로 표현으로 변환하거나 영방향으로 변환하기 등에 자주 사용된다.  

http4k는 코틀린 코드의 함수적 특성을 강력히 포용하며, 요청과 응답에 대해 단순하고 균일한 추상화를 제공한다.  

<br/>

### 모바일 개발: 안드로이드는 코틀린 우선이다

안드로이드는 2017년부터 코틀린을 앱 빌딩을 위한 언어로 공식 지원하기 시작했고, 2019년부터 앱 개발에 코틀린을 디폴트로 제공하는 정책을 채택했다.  

모바일 앱은 보통 더 다양한 디바이스에 대해 운용 신뢰성을 보장하면서 더 빠르게 개발해 배포할 필요가 있는데, 코틀린은 안드로이드 개발 작업을 적은 코드로 생산성있게 개발할 수 있다.  
안드로이드 팀이 만든 KTX 라이브러리를 사용해 수많은 API에 대한 코틀린 어댑터를 제공받을 수 있어 안드로이드 프로그래밍 경험을 더 개선할 수 있다.  

안드로이드에서 네이티브 사용자 인터페이스를 만들기 위한 구글의 젯팸 컴포즈 툴킷도 코틀린으로 작성됐다.  

코틀린을 사용해도 자바 8이상과 완전 호환되며 코틀린 런타임 시스템은 상당히 작기 때문에 컴파일 후 패키징한 애플리케이션 크기도 많이 늘지 않는다. 대부분 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝하므로, 람다를 사용해도 새로운 객체가 만들어지지 않아 객체 증가로 인한 가비지 컬렉션으로 프로그램이 더 자주 잠시 멈추는 것을 겪지 않아도 된다.  

<br/>

### 다중 플랫폼: IOS, JVM, JS 및 그 외의 플랫폼에서 비즈니스 로직 공유 및 코드 중복 최소화

코틀린이 JVM 외에 지원하는 타깃
- 코틀린을 자바스크립트로 컴파일해서 브라우저나 node.js 같은 런타임에서 코틀린 코드를 실행할 수 있다. 
- 코틀린/네이티브를 사용하면 코틀론 코드를 이진 코드로 컴파일할 수 있다. 이것으로 iOS나 다른 플랫폼에서 프로그램을 만들 수 있다.
- 코틀린/와즘은 현재 아직 개발중이지만 코틀린 코드를 웹어셈블리 바이너리 형식으로 컴파일할 수 있다.

코틀린은 여러 타깃에 대해 소프트웨어의 공유와 플램폼별 구현을 세밀하게 제어할 수 있어, 공통 코드와 플랫폼별 코드를 최신의 조합으로 섞어 사용할 수 있다. 코드 공유의 사례는 안드로이드와 iOS 모두를 타깃으로 하는 애플리케이션이다.

<br/>
<br/>

## 코틀린의 철학

코틀린에 대해 말할 때 상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어라고 말하는데, 의미를 살펴본다.    

<br/>

### 코틀린은 실용적인 언어다

실용적이란 것은 코틀린이 실제 문제를 해결하기 위해 만들어진 언어라는 것이다.   
코틀린은 대규모 시스템 IT 업계 경험을 바탕으로 이뤄졌고, 특성은 수많은 개발자들의 사용에 잘 맞도록 주의 깊게 선택됐다. 그리고 전 세계 개발자들이 사용하며 피드백이 반영되고 있다.  

코틀린은 연구를 위한 언어가 아니며, 다른 프로그래밍 언어가 채택한 성공적으로 검증된 해법과 기능에 주로 의존한다. 이로 인해 언어의 복잡도가 줄어들고, 이미 아는 개념으로 쉽게 배울 수 있다.  

코틀린은 특정 프로그래밍 스타일이나 패러다임을 강제로 요구하지 않고, 자신이 익숙한 스타일로 개발할 수 있다.  

실용성에 있어 코틀린의 다른 측면은 도구를 강조한다. 편리한 개발 환경도 생산성 향상에 필수적으로 코틀린의 경우 인텔리제이 IDE 플러그인의 개발과 컴파일러의 개발이 맞물려있으며, 언어 특성은 항상 도구의 활용을 염두해 두고 설계됐다.  

<br/>

### 코틀린은 간결하다

개발자가 코드를 해석하는데는 많은 시간이 드는데, 버그가 일어난 코드를 수정하기 위해서는 많은 코드를 읽어야 한다.  

코드가 간결할수록 코드 해석은 쉬워지며, 주석이나 변수명 잘 짓기 외에 언어가 제공하는 간결함은 내용파악에 큰 도움을 준다. 코틀린은 개발자가 작성하는 코드가 의미를 최대한 전달하고 프로그램 언어가 요구하는 구조를 만족시키기 위한 요소를 줄이기 위해 많은 노력을 기울였다.  
getter, setter, 생성자 등 객체지향 언어의 준비 코드 및 컴파일러가 문맥의 타입을 추론, 여러 풍부한 라이브러리 등 많은 기능을 제공한다.  

코드가 간결하면 코드를 쓰는 시간과 읽는 시간을 모두 절약할 수 있다. 이는 개발 생산성을 향상시킨다.  

<br/>

### 코틀린은 안전하다

안전하다는 것은 오류를 방지해준다는 것이다. 모든 오류를 막을 수는 없으므로 이는 절대적이지 않지만, 개발에는 빠른 생산성과 안정성 사이의 트레이드 오프는 존재한다.  

코틀린을 JVM에서 실행한다는 것은 이미 상당한 안정성을 보장한다는 것으로, JVM으로 메모리 안정성을 보장하고 버퍼 오버플로를 방지하며, 동적으로 할당한 메모리를 잘못 사용함으로써 발생할 수 있는 다른 문제를 예방할 수 있다.  
코틀린은 정적 타입 지정 언어로 타입 안정성을 보장, 읽기 전용 변수를 쉽게 정의, 불변 변수를 묶어 만드는 불변 클래스로 만들어 멀티 스레드 애플리케이션에서 안정성을 보장할 수 있다.

코틀린이은 컴파일 시점 검사로 오류를 미리 방지하고 null이 될 수 없는 값을 추적하여 NullPointerException을 예방해준다. 또한 클래스 캐스트 예외를 방지해주는데 타입 검사와 캐스트를 한 연산자로 수행하여 객체의 타입을 검사했다면 그 객체의 멤버를 별도의 캐스트나 재선언이나 타입 검사 없이 사용할 수 있게 해준다.  

<br/>

### 코틀린은 상호 운용성이 좋다

상호운용성이 좋은 이유
- 코틀린은 자바 등의 기존 언어의 라이브러리를 그대로 사용할 수 있다.
- 자바 코드에서 코틀린 코드를 호출할 때도 아무 노력이 필요하지 않다. 자바 프로젝트에서 코틀린을 섞어서 쓸 수 있는 유연함을 제공한다.
- 기존 자바 라이브러리를 최대한 활용한다. 자바 표준 라이브러리 클래스에 의존하며 코틀린은 컬렉션을 더 쉽게 활용할 수 있게 함수를 확장할 뿐이다.
- 코틀린이 제공하는 도구도 다중 언어 프로젝트를 완전히 지원한다. 자바와 코틀린 소스 파일이 섞여 있어도 관계없이 컴파일할 수 있다.
  - 자바와 코틀린 소스 파일을 자유롭게 네비게이션 할 수 있음
  - 여러 언어를 사용한 프로젝트를 디버깅하며 서로 다른 언어로 작성된 코드를 한 단계씩 실행할 수 있음
  - 자바 코드를 리펙토링해도 코틀린 코드까지 제대로 변경되며 반대도 같음

<br/>
<br/>

## 코틀린 도구 사용

### 코틀린 코드 설정과 실행

코틀린은 [코틀린 온라인 놀티어](https://play.kotlinlang.org/)에서 실행하거나 인텔리제이와 같은 IDE에서 실행 가능하다. 그리고 자바-코틀린 변환기를 사용해서 자바 코드를 코틀린 코드로 자동으로 변환할 수 있다.  

<br/>

### 코틀린 코드 컴파일

코틀린 컴파일할 수 있는 타겟
- JVM에서 실행되는 JVM 바이트코드
- 추가 변환 후 안드로이드에서 실행되기 위한 JVM 바이트코드
- 다른 운영체제에서 네이티브로 실행되기 위한 네이티브 타겟
- 브라우저에서 실행되기 위한 자바스크립트  

코틀린 컴파일러에게 JVM 바이트코드가 JVM에서 실행될지 더 변환된 후 안드로이드에서 실행될지는 중요하지 않다.  

#### **코틀린/JVM에서의 컴파일 과정**

코틀린 소스코드를 저장할 때는 보통 .kt 확장자를 파일에 붙인다. 

코틀린 컴파일러는 소스 코드를 분석해서 .class 파일을 만들어낸다. 이 파일은 애플리케이션 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다.  

```bash
kotlinc <소스파일 또는 디렉토리> -include-runtime -d <jar 이름>
java -jar <jar 이름>
```

자바 가상머신은 원래 코드가 자바인지 코틀린인지 알지 못해도 빌드된 .class 파일을 실행할 수 있지만, 코틀린 내장 클래스와 API는 의존관계로 **코틀린 런타임 라이브러리**라는 추가 정보가 필요하다. 코틀린 런타임 라이브러리는 코틀린 기본 클래스의 정의 및 표준 자바 API의 확장이 들어가있다.  
커맨드 라인에서 코드를 컴파일할 때는 명시적으로 `-include-runtime`을 호출해서 jar 파일 안에 런타임 라이브러리를 포함시켜야 한다.   

추가적으로 코틀린 표준 라이브러리도 애플리케이션의 의존 관계로 필요하다. List, Map, Sequence 같은 기초 클래스와 이런 클래스에 대해 작동하는 수많은 메서드가 들어가 있다.   

코틀린은 Maven, Gradle 등의 빌드 시스템과 호환되며, 이런 빌드 시스템은 모두 빌드 시 알아서 코틀린 런타임과 최신 코틀린 표준 라이브러리를 의존관계에 포함시켜준다.  

gradle의 프로젝트를 설정하는 세부 방법의 최신 내용을 [공식문서](https://kotlinlang.org/docs/gradle.html)를 참조한다.  

<br/>
