# 1. SQL 처리과정과 I/O


## SQL 파싱과 최적화


### 구조적, 선언적, 집합적 질의 언어

SQL(Structured Query Langeuage) : 구조적 질의 언어  

SQL은 기본적으로 구조적(Structured)이고 집합적(Set-based)이고 선언적(Declearative)인 질의 언어이다.  

원하는 결과집합을 구조적, 집합적으로 선언하지만, 만드는 과정은 절차적일 수 밖에 없다. 즉, 프로시저가 필요한데, 만들어 내는 DBMS 내부 엔진이 SQL 옵티마이저이다.   

사용자가 SQL을 작성하면 옵티마이저가 실행계획을 짜서 프로시저를 생성한다.  

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 ‘SQL 최적화’ 라고 한다.  
<br/>
<br/>

### SQL 최적화

**1) SQL 파싱** : 사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서(Parser)가 파싱을 진행한다.

- 파싱 트리 생성 : SQL문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
- Syntax 체크 : 문법적 오류가 없는지 확인. (키워드)
- Semantic 체크 : 의미상 오류가 없는지 확인. ( 테이블 존재 여부, 사용한 오브젝트의 권한 여부)

**2) SQL 최적화** : 데이터베이스 성능을 결정하는 핵심 엔진인 옵티마이저(Optimizer)가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택한다.  

**3) 로우 소스 생성** : 로우 소스 생성기(Row-Source-Generator)가 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계이다.  
<br/>
<br/>

### SQL 옵티마이저

사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 접근 경로를 선택해주는 DBMS의 핵심 엔진이다.  

1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.  

2) 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.  

3) 최저 비용을 나타내는 실행계획을 선택한다.  

옵티마이저는 별도의 프로세스가 아닌 서버 프로세스가 가진 기능(Function)일 뿐이다.  
<br/>
<br/>

### 실행계획과 비용

실행계획이란 SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것이다.  

비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 또는 예상 소요시간을 표현한 값이다.  
<br/>
<br/>

### 옵티마이저 힌트

옵티마이저도 대부분 좋은 선택을 하지만, 완벽하진 않다.  

옵티마이저는 통계정보에 담을 수 없는 데이터 또는 업무 특성을 활용해 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있는데, 이 때 옵티마이저 힌트가 사용된다.
<br/>

```sql
-- 사용법 : 주석기호에 + 를 붙이면 된다.
SELECT /*+ INDEX(A 사원_PK) */
	사원명, 연략처, 주소, 가입일시
FROM 사원 A 
WHERE 사원ID = '00000001'
```
<br/>

**주의 사항**  

```sql
-- 힌트 안에 인자를 나열할 때 콤마(,)를 사용할 수 있지만, 힌트와 힌트사이에 사용할 수 없다.
/*+ INDEX(A A_X01) INDEX(B, B_XO3) */ -> 모두 유효
/*+ INDEX(C), FULL(D) */ -> 첫 번째 힌트만 유효

-- 테이블을 지정할 때 아래와 같이 스키마명까지 명시하면 안된다.
SELECT /*+ FULL(SCOTT.EMP */ -> 무효
	FROM EMP

-- FROM절에 ALIAS를 지정했다면 힌트에도 ALIAS를 사용해야 한다.
SELECT /*+ FULL(EMP */ -> 무효
	FROM EMP E
```
<br/>

### **자주 사용하는 힌트 목록**  

**최적화 목표**  

`ALL_ROWS`

: 전체 처리속도 최적화  

`FIRST_ROWS(N)`

: 최초 N건 응답속도 최적화  
<br/>

**액세스 방식**  

`FULL`

: Table Full Scan으로 유도  

`INDEX`

: Index Scan으로 유도  

`INDEX_DESC`

: Index를 역순으로 스캔하도록 유도  

`INDEX_FFS`

: Index Fast Full Scan으로 유도  

`INDEX_SS`

: Index Skip Scan으로 유도   
<br/>

**조인 순서**  

`ORDERED`

: FROM 절에 나열된 순서대로 조인  

`LEADING`

: LEADING 힌트 괄호에 기술한 순서대로 조인.  

: ex) `LEADING(T1 T2)`

`SWAP_JOIN_INPUTS`

: 해시 조인 시, BUILD INPUT을 명시적으로 선택.  

: ex) `SWAP_JOIN_INPUTS`
<br/>

**조인 방식**  

`USE_NL`

: NL 조인으로 유도  

`USE_MERGE`

: 소트 머지 조인으로 유도  

`USE_HASH`

: 해시 조인으로 유도  

`NL_SJ`

: NL 세미조인으로 유도  

`MERGE_SJ`

: 소트 머지 세미조인으로 유도  

`HASH_SJ`

해시 세미조인으로 유도  
<br/>

**서브쿼리 팩토링**  

`MATERIALIZE`

: WITH 문으로 정의한 집합을 물리적으로 생성하도록 유도.  

: ex) `WITH /*+ MATERIALIZE */ T AS ( SELECT … )`

`INLINE`

: WITH 문으로 정의한 집합을 물리적으로 생성하지 않고 INLINE 처리하도록 유도  

: ex) `WITH /*+ INLINE */ T AS ( SELECT … )`
<br/>

**쿼리 변환**

`MERGE`

: 뷰 머징 유도  

`NO_MERGE`

: 뷰 머징 방지  

`UNNEST`

: 서브쿼리 Unnesting 유도  

`NO_UNNEST`

: 서브쿼리 Unnesting 방지  

`PUSH_PRED`

: 조인조건 Pushdown 유도  

`NO_PUSH_PRED`

: 조인조건 Pushdown 방지  

`USE_CONCAT`

: OR 또는 IN-List 조건을 OR-Expansion으로 유도  

`NO_EXPAND`

: OR 또는 IN-List 조건에 대한 OR-Expansion 방지  
<br/>

**병렬 처리**

`PARALLEL`

: 테이블 스캔 또는 DML을 병렬방식으로 처리하도록 유도  

: ex) `PARALLEL(T1 2) PARALLEL(T2 2)`  

`PARALLEL_INDEX`

: 인덱스 스캔을 병렬 방식으로 처리하도록 유도

`PO_DISTRIBUTE`

: 병렬 수행 시 데이터 분배 방식 결정

: ex) `PQ_DISTRIBUTE(T1 HASH HASH)`
<br/>

**기타**

`APPEND`

: Direct-Path Insert 로 유도  

`DRIVING_SITE`

: DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정(Local 또는 Remote)  

`PUSH_SUBQ`

: 서브쿼리를 가급적 빨리 필터링하도록 유도  

`NO_PUSH_SUBQ`

: 서브쿼리를 가급적 늦게 필터링하도록 유도  
<br/>
<br/>

## SQL 공유 및 재사용

### 소프트 파싱 vs 하드파싱

SQL 파싱, 최적화, 로우 소스 생성 과정을 커쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 라이브러리 캐시(Library Cache)라고 한다.  

라이브러리의 캐시는 SGA(System Global Area)의 구성요소로, SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스 하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다.

![Untitled](https://user-images.githubusercontent.com/95058915/236617019-9266c35c-0248-4f58-a065-71fac87e6102.png)
<br/>

사용자가 SQL 문을 전달하면 DBMS는 SQL을 파싱한 후, 해당 SQL이 라이브러리 캐시에 존재하는 지 확인하고 캐시에서 찾으면 바로 실행단계로 넘어가지만, 찾지 못하면 최적화 단계를 거친다.  

캐시에서 실행단계로 바로 넘어가는 것을 소프트 파싱(Soft Parsing), 캐시에서 찾지 못해 최적화 및 로우 소스 생성(프로시저 생성) 단계까지 모두 거치는 것을 하드 파싱(Hard Parsing)이라고 한다.


![Untitled](https://user-images.githubusercontent.com/95058915/236456285-85514bcc-3da9-481e-90d1-2c73722aca07.png)
<br/>

**SQL 최적화가 하드(Hard)한 이유**  

5개의 테이블을 조인 한다 할 때의 경우의 수 120(5!)  

옵티마이저가 사용하는 정보

- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
- 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

하나의 쿼리를 수행하는 데 있어 후보군이 되는 무수히 많은 실행경로를 도출하고, 짧은 순간에 딕셔너리와 통계정보를 읽어 각각에 대한 효율성을 판단하는 과정은 가벼울 수 없다.  

데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되는 반면, 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업중 하나이다.  

이렇게 어려운 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버리면 비효율 적이기 때문에, 라이브러리 캐시가 존재한다.
<br/>
<br/>

### 바인드 변수의 중요성

**이름없는 SQL 문제**  

사용자 정의 함수/프로시저, 트리거 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 상제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하며 재사용한다.  

SQL은 이름이 따로 없다. 전체 SQL 텍스트가 이름 역할을 한다. SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생되는 구조이기 때문에 이름을 따로 갖는 것이 비효율 적이다. 처음 실행할 때  최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로 써 여러 사용자가 공유하며 재사용하고, 캐시 공간이 부족하면 버리졌다가 다음에 다시 실행할 때 같은 최적화 과정을 거쳐 캐시에 적재된다.

이러한 것을 방지하기 위해서 바인드 변수를 사용하는 것이 유리하다.

`String sql = “SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?”;`

`SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1;`

이 SQL에 대한 하드파싱은 최초 한 번만 일어나고, 캐싱된 SQL을 사용자가 공유하며 재사용된다.  
<br/>
<br/>

## 데이터 저장 구조 및 I/O 메커니즘

I/O 튜닝이 곧 SQL 튜닝이라고 해도 과언이 아니다. SQL 튜닝원리를 이해하려면 I/O에 대한 이해가 중요하다.  
<br/>
<br/>

### SQL이 느린 이유

SQL 이 느린 이유는 I/O 때문이다. 구체적으로 디스크 I/O 때문이다.  

OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 Sleep 상태가 되기 때문이다.  

프로세스(Process)는 실행 중인 프로그램이며, 생성(new) 이후 종료(terminated) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복한다. 실행중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시 실행 상태로 전환한다. 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이런 메커니즘이 필요하다.

![Untitled (1)](https://user-images.githubusercontent.com/95058915/236456318-02e48bf5-ecc9-4ba0-a0ee-2e0b3893012d.png)
<br/>

interrupt 없이 열심히 일하던 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 잠시 수면(waiting) 상태에서 I/O가 완료되기를 기다린다.
<br/>
<br/>

### 데이터베이스 저장 구조

![Untitled (2)](https://user-images.githubusercontent.com/95058915/236456335-70b74714-390e-4d04-a3e2-6fad503afbaf.png)
<br/>

**데이터 파일**  

- 디스크 상의 물리적인 OS 파일이다.  

**오브젝트(Object)**  

- 오라클에서 데이터를 관리하기 위해 생성하는 모든 것  
- table, index, view, sequence 등  

**테이블 스페이스**  

- 데이터베이스 오브젝트 내 데이터를 저장하기 위해 생성한다.
- 세그먼트를 담는 컨테이너로, 여러 개의 데이터 파일(디스크 상의 물리적인 OS 파일)로 구성된다.  
- 단지 데이터베이스 저장소 위치를 지정하며, 논리적인 데이터베이스 구조나 스키마를 지정하지 않는다.
<br/>

**세그먼트**  

- 테이블, 인덱스처럼 데이터 저장공간을 갖고있는(저장공간이 필요한) 오브젝트다. 
- 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
- 여러 익스텐드로 구성되며, 파티션 구조가 아니라면, 테이블 또는 인덱스가 하나의 세그먼트이다.
- 파티션 구조라면, 각 파티션이 하나의 세그먼트가 된다.
- LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 별도의 공간에 값을 저장한다.  
- 세그먼트를 구성하는 여러 익스텐트 중 첫 번째 익스텐트의 첫 번째 블록에 세그먼트의 전체 요약 정보(Segment Header)가 들어가게 된다.(익스텐드 할당 상태 및 공간 사용 내역 등)
<br/>

**익스텐드**  

- 공간을 확장하는 단위이다.
- 연속된 블록들의 집합이기도 하며, 여러 개의 데이터 블록으로 구성된다.
- 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블 스페이스로부터 익스텐드를 추가로 할당받는다.
- 한 익스텐드는 하나의 테이블이 독점한다. (한 익스텐드에 담긴 블록은 모두 같은 테이블 블록)  
<br/>

**블록**   

- 사용자가 입력한 레코드를 실제로 저장하는 공간이다.(데이터를 읽고 쓰는 단위)
- DB2, SQL Server 같은 DBMS는 블록 대신 페이지(page)라는 용어를 사용한다.
- 한 블록은 하나의 테이블이 독점한다. (한 블록에 저장된 레코드는 모두 같은 테이블 레코드)  
<br/>

**DBA(Data Block Address)**  

- 데이터 블록이 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값이다.
- 데이터를 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 먼저 DBA부터 확인해야 한다.
- 인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 이용한다.
- ROWID는 DBA + 로우 번호(블록 내 순번)로 구성되며, 분해를 통해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.
- 테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐드 맵을 이용하며, 이를 통해 각 익스텐드의 첫 번째 블록 DBA를 알 수 있다.
<br/>
<br/>

### 테이블 스페이스 종류

테이블 스페이스에는 오라클의 동작에 필요한 영구 테이블 스페이스와 데이터 저장용 영구 테이블 스페이스가 있다  

- 오라클 동작용 : SYSTEM, SYSAUX 테이블 스페이스  
- 데이터 저장용 : UNDO, TEMPORARY(임시) 테이블 스페이스  
<br/>

**SYSTEM 테이블 스페이스**  

- 데이터베이스를 생성할 때 자동으로 생성되는 테이블 스페이스
- 오라클이 동작하는 데 필요한 관리 정보를 가진 Data Dictionary 및 프로시저, 함수, 패키지 및 트리거 등이 저장된다.  
<br/>

**SYSAUX 테이블 스페이스**  

- 컴포넌트(오라클의 기능을 확장하는 소프트웨어)가 동작하는데 필요한 관리 정보가 저장되어 있다.

SYSTEM, SYSAUX 테이블 스페이스에도 사용자가 생성한 테이블, 인덱스 등의 오브젝트를 저장할 수 있지만, 오라클 동작에 필요한 오브젝트와 사용자가 정의한 오브젝트가 섞이면 관리하기 어려워지므로 따로 저장하는 것이 좋다.  
<br/>

**UNDO 테이블 스페이스**    

- UNDO 세그먼트를 저장하기 위한 테이블 스페이스
- 테이블이나 인덱스 등의 오브젝트를 저장하는 것은 불가능하다.
- UNDO 세그먼트란 변경 전의 데이터를 보관하는 특수한 영역이다.
- UNDO 세그먼트의 데이터는 트랜잭션의 롤백이나 읽기 일관성(read consistency)을 위해 변경전 데이터를 읽어야 할 경우 사용된다.  
<br/>

**TEMPORARY 테이블 스페이스**  

- 임시 세그먼트라고 불리는 작업용 디스크 영역을 보관하기 위한 특수한 테이블 스페이스
- 테이블이나 인덱스 등의 오브젝트를 저장하는 것은 불가능하다.
- 임시 세그먼트란 SQL 처리에 필요한 일시적인 작업 영역을 메모리상에 확보할 수 없을 때 할당되는 작업용 디스크 공간이다.
- SQL 처리를 할 때 데이터 양이 적은 경우에는 PGA의 SQL Work Areas에서 처리되지만, 데이터양이 많으면 작업에 필요한 공간 크기가 SQL Work Areas의 크기를 넘어버리므로 임시 세그먼트를 할당한다.  
<br/>
<br/>


### 블록 단위 I/O

클라우드에 위치한 문서는 파일 단위로 저장하고, 파일 단위로 읽는다.  

DBMS가 데이터를 읽고 쓰는 단위는 블록이다.  

데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽고, 1Byte 컬럼 하나만 읽고 싶어도 블록을 통으로 읽는다.  

테이블뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다.  
<br/>

![Untitled](https://user-images.githubusercontent.com/95058915/236508804-0519dfc8-c02f-403c-ab70-73be413f1680.png)
<br/>

```sql
-- 블록 사이즈 확인
show parameter block_size;
```
<br/>
<br/>

### 시퀀셜(Sequenctial) 액세스 vs 랜덤 액세스

테이블, 인덱스 블록을 액세스(읽는) 하는 방식으로는 두 방법이 있다.

![Untitled (2)](https://user-images.githubusercontent.com/95058915/236509119-19814fa8-4725-4775-84f5-6b9505be0910.png)
<br/>

**시퀀셜 엑세스**  

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방법이다.
- 인덱스 리프 블록은 앞 뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있다. 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이다.
<br/>

**랜덤 액세스**  

- 논리적, 물리적인 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근(=touch)하는 방식이다.
- 위 그림의 점선 화살표에 해당한다.
<br/>
<br/>

### 논리적 I/O vs 물리적 I/O

**DB 버퍼캐시**  

DB 버퍼캐시도 SGA의 가장 중요한 구성요소중 하나이다.

라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 코드 캐시라고 한다면, DB 버퍼캐시는 데이터 캐시라고 할 수 있다.  

디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다.

![Untitled (4)](https://user-images.githubusercontent.com/95058915/236456403-e251ff4e-26d3-4d93-bb8f-56dcb901eb58.png)
<br/>

서버 프로세스와 데이터 파일 사이에 버퍼 캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다. 이로 인해 프로세스가 잠(I/O Call)을 자지 않아도 된다.  

버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다.  
<br/>

```sql
-- 오라클의 버퍼캐시 사이즈 확인
show sga
```
<br/>

**논리적 I/O vs 물리적 I/O**

![Untitled (5)](https://user-images.githubusercontent.com/95058915/236456414-4184b565-2ca5-44ab-a771-38fd78d7cfce.png)
<br/>

논리적 블록 I/O는 SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 말한다. Direct Path I/O가 작동하는 경우가 있으므로 논리적 I/O와 메모리 I/O가 정확히 같은 의미는 아니지만, 일반적으로 같다고 봐도 무방하다.  

물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말한다. SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스 하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O한다.

메모리 I/O는 전기적 신호인데 반해, 디스크 I/O는 액세스 암(Arm)을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 약 10,000배쯤 느리다.  
<br/>

**왜 논리적 I/O인가?**

SQL을 수행하려면 데이터가 담긴 블록을 읽어야 한다. SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서 조건절에 같은 변수 값을 입력하면, 아무리 여러번 실행해도 매번 읽는 블록 수 는 같다. SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O다.   

Direct Path Read 방식으로 읽는 경우를 제외하면 모든 블록은 DB 버퍼캐시를 경유해서 읽는다. 따라서 논리적 I/O 횟수는 DB 버퍼캐시에서 블록을 읽은 횟수와 일치한다. 논리적 I/O가 메모리 I/O와 같은 개념은 아니지만, 결과적으로 수치는 같다.  

DB 버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O가 물리적 I/O다. 데이터 입력이나 삭제가 없어도 물리적 I/O는 SQL을 실행할 때마다 다르다. 연속해서 실행하면 DB 버퍼 캐시에서 해당 테이블 블록의 점유율이 점점 높아지기 때문에 첫 번째 실행할 때보다 두 번째 실행할 때 줄어들고, 세 번째 실행할 땐 더 줄어든다. 한참 후에 다시 실행하면 DB 버퍼캐시가 다른 테이블 블록으 로 채워지기 때문에 반대로 물리적 I/O가 늘어난다.  
<br/>
<br/>

### 버퍼캐시 히트율

버퍼캐시 효율을 측정하는 데 가장 많이 사용해 온 지표는 버퍼캐시 히트율(Buffer Cache Hit Ratio, BCHR)이다.  

BCHR은 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 나타낸다.  

애플리케이션 특성에 따라 다르지만, 온라인 트랜잭션을 주로 처리하는 애플리케이션 이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.  

```
BHCR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) × 100
		 = ( ( 논리적 I/O - 물리적 I/O ) / 논리적 I/O ) × 100
		 = ( 1 - ( 물리적 I/O ) / (논리적 I/O ) ) × 100
```

BCHR 공식을 보면 물리적 I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다.

- 물리적 I/O = 논리적 I/O × ( 100 - BCHR )

논리적 I/O를 줄이기 위해선 SQL을 튜닝해서 읽는 총 블록 개수를 줄이면 된다. 논리적 I/O는 항상 일정하게 발생하지만, SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생변수다.(물리적 I/O는 외생변수) **논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝**이다.
<br/>
<br/>

### Single Block I/O vs Multi Block I/O

캐시에는 데이터의 일부만 적재 가능하며, 캐시에서 찾지 못한 데이터 블록은 I/O Call을 통해 디스크에서 DB 버퍼캐시로 적재하고서 읽는다. I/O Call 할 때, 한번에 한 블록씩 요청하기도 하고, 여러 블록씩 요청하기도 한다.   

- Single Block I/O : 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
- Multi Block I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식

기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다.  
<br/>

**Single Block I/O 대상 오퍼레이션**

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

많은 데이터 블록을 읽을 때는 Multi Block I/O가 효율적이다. 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다. 테이블이 클 수록 Multi Block I/O 단위도 크면 좋다. 프로세스가 잠자는 횟수를 줄여줄 수 있다.  

![Untitled (6)](https://user-images.githubusercontent.com/95058915/236456484-b1128b4d-f434-45bc-ba0a-7ecff41d2881.png)
<br/>

읽고자 하는 블록을 DB 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O Call을 한다. 그동안 프로세스는 대기 큐(Wait Queue)에서 잠을 자게 되는데, Multi Block I/O 단위를 크게 해서 잠 자는 횟수를 줄여 성능을 높일 수 있다.  

즉, Multi Block I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.  

Multiblock I/O에서 인접한 블록이란 같은 익스텐트에 속한 블록을 의미한다. 따라서 Multiblock I/O 방 식으로 읽더라도 익스텐트 경계를 넘지 못한다는 뜻이다.  
<br/>
<br/>

### Table Full Scan vs Index Range Scan

**Table Full Scan :** 테이블에 속한 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식

**Index Range Scan(인덱스를 이용한 테이블 액세스)** : 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식

Table Full Scan은 시퀀셜 액세스와 Multi Block I/O 방식으로 디스크 블록을 읽는다. 한 블록에 속한 모든 레코드를 한 번에 읽어들이고, 캐시에서 못 찾으면 한번의 수면(I/O Call)을 통해 인접한 수십 ~ 수백 개 블록을 한꺼번에 I/O하는 메커니즘이다. 큰 테이블에서 소량 데이터를 검색할 때는 인덱스를 이용하는 것이 좋다.  

Index Range Scan은 랜덤 액세스와 Single Block I/O 방식으로 디스크 블록을 읽는다. 캐시에서 블록을 못 찾으면, 레코드 하나를 읽기 위해 매번 잠을 자는 I/O 메커니즘이다. 이 방식은 읽었던 블록을 반복해서 읽는 비효율이 있다. 많은 데이터를 읽을 때 물리적인 블록 I/O 뿐만 아니라 논리적인 블록 I/O 측면에서도 불리하다는 얘기다. 한 블록 에 평균 500개 레코드가 있으면, 같은 블록을 최대 500번 읽는다.  

인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾기위한 도구일 뿐이므로 모든 성능 문제를 인덱스로 해결하려 해선 안된다. 읽을 데이터가 일정량을 넘으면 인덱스보다 Table Full Scan이 유리하다.
<br/>
<br/>

### 캐시 탐색 메커니즘

Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.  

아래 오퍼레이션은 모두 버퍼캐시 탐색 과정을 거친다.  

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 일을 때
- 테이블 블록을 Full Scan 할 때

![Untitled (7)](https://user-images.githubusercontent.com/95058915/236456519-c10eece1-87b9-48ea-b91c-7bb0944853ef.png)
<br/>

그림은 해시함수로 모듈러(mod) 함수를 사용하는 경우를 표현하고 있다. 실제로는 훨씬 더 정교한 알고리즘을 사용하지만, 그림은 5로 나누었을 때의 나머지 값을 반환하는 모듈러 함수이다.  

버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터(Pointer)로 블록을 액세스 하는 방식을 사용한다. 해시구조의 특징을 요약하면 다음과 같다.  

- 같은 입력 값은 항상 동일한 해시 체인(=버킷)에 연결됨
- 다른 입력 값(ex. 4와 9)이 동일한 해시 체인(=버킷)에 연결될 수 있음
- 해시 체인 내에서는 정렬이 보장되지 않음
<br/>

**메모리 공유자원에 대한 액세스 직렬화**

버퍼캐시는 SGA 구성요소이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이다. 공유자원은 누구나 접근할 수 있다. 문제는 하나의 버퍼블록을 두 개 이상 프로세스가 동시에 접근하려고 할 때 발생한다.(정합성 문제)

자원을 공유하는 것처럼 보여도 내부에선 한 프로세스씩 순차적으로 접근하도록 구현하기 위해 직렬화 (serialization) 메커니즘이 필요하다.(줄 세우기) 

이러한 줄 서기가 가능하도록 지원하는 것이 래치(Latch)이다. SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하는데, 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 작동한다. 빠른 데이터베이스를 구현하려면 버퍼캐시 히트율을 높여야 하지만, 래치에 의한 경합으로 캐시 I/O도 생각만큼 빠르지 않을 수 있다.

캐시버퍼 체인뿐만 아니 라 버퍼블록 자체에도 직렬화 메커니즘 버퍼 Lock이 존재한다. 이런 직렬화 메커니즘에 의 한 캐시 경합을 줄이려면, SQL 튜닝을 통해 쿼리 일량(논리적 I/O)자체를 줄여야 한다.

버퍼 Lock은 캐시버퍼 체인 래치를 해제하기 전에 버퍼 해더에 Lock을 설정함으로써 버퍼블록 자체에 대한 직렬화 문제를 해결하는 것이다.

<br/>
<br/>
<br/>
<br/>
<br/>

### 참조
- 친절한 SQL 튜닝
