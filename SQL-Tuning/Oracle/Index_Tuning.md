# 인덱스 튜닝

인덱스를 스캔하는 이유는?   

검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID)를 얻기 위해서.   
<br/>

ROWID?  

디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는 논리적 주소이다.  

테이블 레코드와 물리적으로 직접 연결된 구조는 아니다.  

인덱스로 테이블 블록을 액세스할 때는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고, 테이블을 Full Scan 할 때는 익스텐드 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.  

ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 때만 디스크에서 블록을 버퍼 캐시에 적재한 후 읽는다.  
<br/>
<br/>

### 인덱스 클러스터링 펙터

클러스터링 팩터(Clustering Factor, CF)란 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.  

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다.  
<br/>
<br/>

### 인덱스 손익분기점

인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.  

읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다. Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 인덱스 손익 분기점이라 한다.  

인덱스를 이용해 테이블을 액세스 할 때는 대용량 데이터 중 몇 건을 추출하느냐에 따라 성능이 크게 달라진다.  
<br/>

인덱스를 이용한 테이블 액세스가 Table FullScan보다 더 느려지게 만드는 두가지 요인

- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
- Table Full Scan은 Multi Bliock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.  

이런 요인으로 인해 인덱스 손익 분기점은 보통 5~20%의 낮은 수준에서 결정된다.  
<br/>

![Untitled (1)](https://github.com/Reffy08/TIL/assets/95058915/5fd46441-6643-4485-b541-7bf470358aea)  
<br/>

IOT(Index Organized Table)  
<br/>
<br/>

## 부분범위 처리

전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것  
<br/>
<br/>

## 인덱스 스캔 효율화

선행 컬럼이 조건절에 있어야 인덱스를 타게된다.

**인덱스 액세스 조건**은 인덱스 스캔 범위를 결정하는 조건절이다. (인덱스 스캔 시작점을 결정하고, 리프 블록을 스캔하다 어디서 멈출 지 결정)  
<br/>

**인덱스 필터 조건**은 테이블로 액세스할지를 결정하는 조건절이다.  
<br/>
<br/>

### 비교 연산자 종류와 컬럼 순서에 따른 군집성

선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.
<br/>

```sql
where c1 = 1
and c2 = 'A'
and c3 = between '가' and '다' -- 인덱스 스캔 범위를 결정
and c4 = 'a'

where c1 = 1
and c2 <= '8' -- 인덱스 스캔 범위를 결정
and c3 = '나'
and c4 between 'a' and 'b'

where c1 between 1 and 3 -- 선두 컬럼이 스캔범위를 결정하고 나머지는 인덱스 필터 조건이된다.
and c2 = 'A'
and c3 = '나'
and c4 = 'a'
```
<br/>

선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.(인덱스 액세스 조건)  

나머지 컬럼은 인덱스 필터 조건이 된다.  
<br/>
<br/>

### 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

인덱스 선행 컬럼이 모두 = 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.  
<br/>
<br/>

### BETWEEN을 IN-List로 전환

범위 검색 컬럼에 의한 손해를 BETWEEB 조건을 IN-List 조건으로 변경했을 때 효과를 얻는 경우도 있다.

BETWEEN 조건을 IN-List 조건으로 전환할 때 주의할 점은, IN-List 개수가 많지 않아야 한다는 것이다. IN-List의 개수가 많으면 수직적 탐색이 많이 발생해서, BETWEEN 조건 때문에 리프 블록을 많이 스캔하는 비효율보다 IN-List 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있다. 루트에서 브랜치 블록까지 Depth가 깊을 때 특히 그렇다.  

인덱스 스캔과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다는 사실도 기억해야 한다.  
<br/>
<br/>

### IN 조건은 = 인가?

IN 조건은 = 이 아니다. IN 조건이 = 이 되려면 IN-List Iterator 방식으로 풀려야만 한다.  
<br/>
<br/>

### BETWEEN과 LIKE 스캔 범위 비교
<br/>

```sql
select * from 월별고객판매집계 
where 판매월 like '2020%' and 판매구분 'A'

select * from 월별고객판매집계 
where 판매월 between '202001' and '202012' and 판매구분 'A'
```
<br/>

LIKE보다 BETWEEN을 사용하는 것이 낫다.  

LIKE문은 조건을 모두 수행해야하며 중간에 멈출 수 없다.  
<br/>
<br/>

### 범위검색 조건을 남용할 때 생기는 비효율

LIKE 문을 남용하는 것은 좋지 않다.  
<br/>
<br/>

### 다양한 옵션 조건 처리 방식의 장단점 비교
<br/>

**OR 조건 활용**    

옵티마이저에 의한 OR Expansion 쿼리 변환이 기본적으로 작동하지 않으므로 인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해선 안된다.  

인덱스에 포함되지 않은 컬럼에 대한 옵션조건은 테이블에서 필터링할 수 밖에 없으므로 그럴 때는 OR조건을 사용해도 무방하다.  
<br/>

OR조건을 활용한 옵션 조건 처리

- 인덱스 액세스 조건으로 사용 불가
- 인덱스 필터 조건으로도 사용 불가
- 테이블 필터 조건으로만 사용 가능
- 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 오라클 18c 부터 인덱스 필터 조건으로 사용 가능  
<br/>

이런 특성을 고려한다면, OR조건을 이용한 옵션 조건 처리는 가급적 사용하지 말아야 한다. 유일한 장점이 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과집합을 보장한다는 것이다.  

이후 방식들은 UNION ALL을 제외하면 모두 NULL 허용 컬럼에 사용할 수 없다는 단점이 있다. 결과집합을 보장하지 않기 때문이다.  
<br/>

**LIKE / BETWEEN 조건 활용**    

필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN 이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.  
<br/>

```sql
select * from 상품
where 상품명 := prd_name -- 필수 조건
and 상품분류코드 like :prd_code || '%' -- 옵션 조건
```
<br/>

필수 조건의 변별력이 좋지 않을 때는 고려를 해야 한다.  

LIKE/BETWEEN 패턴을 사용할 때 네 가지 경우에 속하는지 점검하고 네 가지 경우에 속하는 경우에 사용하지 않도록 하는 것이 좋다.(BETWEEN은 1,2번만 고려하면 됨)   

1) 인덱스 선두 컬럼 : 인덱스 스캔 과정의 비효율

2) NULL 허용 컬럼 : 결과 집합의 오류가 생김

3) 숫자형 컬럼 : 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해선 안된다.(자동형변환)

4) 가변 길이 컬럼 : LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다.   
<br/>

**UNION ALL 활용**  
<br/>
```sql
-- :cust_id 변수에 값을 입력했는지에 따라 sql을 선택하여 실행
select * from 거래
where :cust_id is null
and 거래일자 between :dt1 and :dt2
union all
select * from 거래
where :cust_id is not null
and 고객ID = :cust_id
and 거래일자 between :dt1 and :dt2
```
<br/>

이 패턴을 사용하면 :cust_id 변수에 값을 입력하든 안 하든, 인덱스를 가정 최적으로 사용한다. 유일한 단점은 SQL 코딩량이 길어진다는 것이다.  
<br/>

**NVL/DECODE 함수 활용**
<br/>

```sql
select * from 거래
where 고객ID = nvl(:cust_id, 고객ID)
and 거래일자 between :dt1 and :dt2

-- 또는

select * from 거래
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
and 거래일자 between :dt1 and :dt2
```
<br/>

고객 ID 컬럼을 함수 인자로 사용(인덱스 컬럼 가공)했는데도 인덱스를 사용할 수 있는 것은 OR Expansion 쿼리 변환이 일어났기 때문이다. 옵티마이저가 UNION ALL 방식으로 쿼리를 변환한 것이다.  

만약 이 기능이 작동하지 않으면 NVL, DECODE 함수를 사용하는 패턴도 인덱스 액세스 조건으로 사용이 불가능하다.  

이 방식의 가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는데 있다. 즉, UNION ALL 보다 단순하면서도 UNION ALL과 같은 성능을 낸다.  

단점은 LIKE 패턴처럼 NULL 허용 컬럼에 사용할 수 없다. 조건 변수에 NULL을 입력하면 값이 NULL 인 레코드가 결과집합에서 누락되기 때문이다.  
<br/>
<br/>

### 함수호출부하 해소를 위한 인덱스 구성

PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 매우 느리다.

함수를 한두 번 호출할 때는 함수를 사용하지 않았을 때와 비교해 성능 차이를 잘 느끼지 못한다.   
<br/>

PL/SQL 사용자 정의 함수가 느린 이유  

- 가상머신(VM) 상에서 실행되는 인터프리터 언어
- 호출 시마다 컨텍스트 스위칭 발생
- 내장 SQL에 대한 Recursive Call 발생  
<br/>
<br/>

## 인덱스 설계

### 인덱스 설계가 어려운 이유

인덱스가 많으면 생기는 문제  

- DML 성능 저하 (TPS(초당 트랜잭션 수) 저하)
- 데이터베이스 사이즈 증가 (디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승  
<br/>

테이블과 달리 인덱스는 정렬 상태를 유지해야 하므로 수직적 탐색을 통해 입력할 블록부터 찾고, 찾은 블록에 여유 공간이 없으면 인덱스 분할(Index Split)도 발생한다.
<br/>
<br/>

### 가장 중요한 두 가지 선택 기준(인덱스 스캔 효율성 판단 기준)

- 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다. (선두 컬럼을 조건절에 사용해야 한다.)
- = 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.  
<br/>
<br/>

### 스캔 효율성 이외의 판단 기준

- 수행 빈도 (가장 중요)
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하 (기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용
<br/>
<br/>

### 소트 연산을 생략하기 위한 컬럼 추가

인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해준다. 따라서 조건절에 사용하지 않는 컬럼이라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.  
<br/>

I/O를 최소화 하면서 소트 연산을 생략하기 위한 인덱스 구성 공식

- = 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- = 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정  
<br/>

**IN 조건은 = 이 아니다**  

IN 조건이 = 이 되려면 IN-List Iterator 방식으로 풀려야 한다.  

소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안된다. 즉, IN 조건절을 인덱스 액세스 조건으로 사용하면 안된다. 필터 조건으로 사용해야 한다.   
<br/>
<br/>

### 결합 인덱스 선택도

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준이다. 선택도(Selectivity)란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율이다. 선택도에 총 레코드 수를 곱해서 카디널리티를 구한다.  

인덱스 선택도는 인덱스 컬럼을 = 로 조회할 때 평균적으로 선택되는 비율을 의미한다. 선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효용가치가 별로 없다. 테이블 액세스가 많이 발생하기 때문이다.  

인덱스를 생성할 때는 반드시 선택도/카디널리티를 확인해야 한다.   
<br/>

**컬럼 순서 결정 시, 선택도 이슈**  

인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연ㅅ나자 형태가 더 중요한 판단 기준이다.
