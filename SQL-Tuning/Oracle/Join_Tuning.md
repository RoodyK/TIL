# 조인 튜닝

## NL조인

Nested Loop join : 중첩 루프 조인

### 기본 메커니즘

NL조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 사용한다.  

Outer쪽은 테이블 사이즈가 크지 않으면 인덱스를 생략해도 되지만, Inner쪽 테이블은 인덱스를 사용해야 한다.  

NL조인은 인덱스를 이용한 조인 방식이라고 할 수 있다.  
<br/>

```sql
-- NL 조인 형태
begin
    for outer in (select e.empno, e.ename, e.deptno from emp e where e.deptno > 20)
    loop -- outer
        for inners in (select d.deptno, d.dname, d.loc from dept d where d.deptno = outer.deptno)
        loop -- inner
            dbms_output.put_line(outer.empno || ', ' || outer.ename || ', ' || inners.deptno);
        end loop;
    end loop;
end;
/
```
<br/>

**NL조인 조건절 비교 순서**  
<br/>

```sql
select /*+ ordered use_nl(c) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호    -- 1번
    and e.입사일자 >= '19960101'    -- 2번
    and e.부서코드 = 'Z123'         -- 3번
    and c.최종주문금액 >= 20000     -- 4번

-- 사원_PK : 사원번호
-- 사원_IDX1 : 입사일자
-- 고객_PK : 고객번호
-- 고객_IDX1 : 관리사원번호
-- 고객_IDX2 : 최종주문금액
```
<br/>

2 → 3 → 1 → 4 순으로 동작

1) 입사일자 >= '19960101' 조건을 만족하는 레코드를 찾으려고 사원_IDX1 인덱스를 Range 스캔

2) 사원_IDX1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 'Z123' 필터 조건을 만족하는지 확인

3) 사원 테이블에서 읽은 사원번호 값으로 조인 조건(c.관리사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객_IDX1 인덱스를 Range 스캔한다

4) 고객_IDX1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다
<br/>

![Untitled](https://github.com/Reffy08/TIL/assets/95058915/3f20916b-5937-4d38-95c9-c110e1128311). 
<br/>
<br/>

## 소트 머지 조인

조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이여서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.

오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다. 각 오라클 서버 프로세스에 할당된 메모리 영역을 PGA(Process/Program/Private Global Area)라고 한다.  

PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 래치 메커니즘이 불필요하다. 같은 양의 데이터를 읽더라도 SGA 버퍼 캐시에서 읽을 때보다 훨씬 빠르다.
<br/>

**SGA(System Global Area)** - 모든 사용자가 공유 가능한 메모리 영역.

**PGA(Progrma Global Area)** - 서버프로세스가 독자적으로 사용 가능하는 메모리 영역.  
<br/>
<br/>

### 기본 매커니즘

1) 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.

2) 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.
<br/>

```sql
-- < 원본 쿼리 >
select /*+ ordered use_merge(c) */
       e.사원번호, e.사원명, e.입사일자,
       c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from   사원 e, 고객 c
where  c.관리사원번호 = e.사원번호
and    e.입사일자 >= '19960101'
and    e.부서코드 = 'Z123'
and    c.최종주문금액 >= 2000

--	  ↓  수행과정 풀이  ↓

-- 1) 사원데이터를 조인 컬럼인 사원번호 순으로 정렬
--    => 결과 집합은 PGA영역의 Sort Area에 저장
--		 (PGA에 담을 수 없을 정도로 크면 Temp테이블 스페이스에 저장)

select 사원번호, 사원명, 입사일자
from   사원
where  입사일자 >= '19960101'
and    부서코드 = 'Z123'
order by 사원번호;

-- 2) 고객 데이터를 조인컬럼인 관리자사원번호 순으로 정렬
--    => 결과 집합은 PGA영역의 Sort Area에 저장
--	     (PGA에 담을 수 없을 정도로 크면 Temp 테이블스페이스에 저장)

select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
from   고객 c
where  최종주문금액 >= 2000
order by 관리사원번호;

-- 3) PGA(또는 Temp 테이블스페이스)에 저장한 사원 데이터를 스캔하면서
--	 위에서 저장한 고객 데이터와 조인한다
--	 (조인하는 과정을 PL/SQL로 표현)

begin
    for outer in (select * from PGA에_정렬된_사원)
    loop      -- outer 루프
        for inner in (select * from PGA에_정렬된_고객 where 관리사원번호 = outer.사원번호)
        loop  -- inner 루프
            dbms_output.put_line( ... );
        end loop;
    end loop;
end;
```
<br/>

### 소트 머지 조인의 주용도

기본 성능 대부분이 해시 조인이 더 빠르기 때문에 아래 용도로 사용

- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(cross join, 카테시안 곱)
<br/>
<br/>

### 소트 머지 조인 특징 요약

소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다. 양쪽 집합을 정렬한 다음에는 NL조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다. 따라서 소트 부하만 감수한다면, 건건히 버퍼캐스를 경유하는 NL 조인보다 빠르다.  

NL조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다.
<br/>
<br/>

## 해시 조인

소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있는데, 해시 조인은 그런 부담도 없다. 그렇다고 모든 조인을 해시 조인으로 처리할 수 는 없으므로, 각 조인 방식의 특성을 이해하고 상황에 맞게 선택해야 한다.
<br/>
<br/>

### 기본 메커니즘

1) Build 단계 : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성한다.

2) Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.  
<br/>

```sql
select /*+ ordered use_hash(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호    
    and e.입사일자 >= '19960101'    
    and e.부서코드 = 'Z123'         
    and c.최종주문금액 >= 20000     
```
<br/>

![Untitled (1)](https://github.com/Reffy08/TIL/assets/95058915/fd70f969-8376-474d-92e9-a22213a2cdae)  
<br/>

1) Build 단계 : WHERE 조건(입사일자, 부서코드)에 해당하는 데이터를 가져온 후, 해시 테이블을 생성한다. 이때, 조인컬럼인 사원번호를 해시 테이블 키 값으로 사용한다. 즉, 사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인 데이터를 연결한다. 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.  

2) Probe 단계 : WHERE 조건(최종주문금액)에 해당하는 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색한다. 즉, 관리사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고 그 해시 체인을 스캔해서 값이 같은 사원번호를 찾는다. 값이 같은 사원번호를 찾으면 조인에 성공한 것이고, 못찾으면 실패한 것이다.  
<br/>
<br/>

### 해시 조인이 빠른 이유

소트 머지 조인이 빠른 이유와 같다.  

해시 테이블을 PGA 영역에 할당하기 때문이다. NL조인은 테이블쪽 레코드를 읽기 위해 래치 획득 및 캐시버퍼 체인 스캔 과정을 반복한다. PGA는 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.
<br/>
<br/>

### 조인 메소드 선택 기준

**일반적인 조인 메소드 선택 기준**  

- 소량 데이터를 조인할 때 : NL조인
- 대량 데이터를 조인할 때 : 해시 조인
- 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때. 즉, 조인 조건식이 등치(=)조건이 아닐 때(조인 조건식이 아예 없는 카테시안 곱 포함) : 소트 머지 조인 
<br/>

**수행빈도가 매우 높은 쿼리 선택 기준**  

- (최적화 된) NL 조인과 해시 조인 성능이 같으면 NL조인
- 해시 조인이 약간 더 빨라도 NL 조인
- NL 조인보다 해시 조인이 매우 빠른 경우, NL 조인  
<br/>

NL 조인에 사용하는 인덱스는 (DBA가 DROP 하지 않는 한) 영구적으로 유지함녀서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다. 반면, 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 구조다. 같은 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개가 만들어진다. 그래서 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다.  
<br/>

**해시 조인 조건을 만족하는 SQL문**   

- 수행 빈도가 낮고, 쿼리 수행 시간이 오래 걸리는 대량 데이터를 조인할 때. 
<br/>

## 서브 쿼리 조인

### 서브 쿼리 변환이 필요한 이유

개발자가 작성한 SQL은 옵티마이저가 최적화에 유리한 형태로 변환하는 작업(쿼리 변환)을 진행한다.

쿼리 변환(Query Transformation)은  옵티마이저가 SQL을 분석해 의미적으로 동일(같은 결과 집합을 생성)하면서도  더 나은 성능이 기대되는 형태로 재작성하는 것이다.

서브쿼리는 하나의 SQL 문 안에 괄호로 묶은 별도의 쿼리 블록이다.  
<br/>

**서브 쿼리 종류**  

- 인라인 뷰(Inline view) : FROM 절에 사용한 서브쿼리
- 중첩된 서브쿼리(Nested Subquery) : 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리. 서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 ‘상관관계 있는 서브쿼리’ 라고 한다.
- 스칼라 서브쿼리(Scalar Subquery) : 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리. 주로 SELECT-LIST에서 사용하지만 몇가지 예외사항을 제외하면 컬럼이 올 수 있는 대부분 위치에 사용할 수 있다.
<br/>
<br/>

### 서브쿼리와 조인

메인쿼리와 서브쿼리 간에는 부모와 자식이라는 종속적이고 계층적인 관계가 존재한다. 서브쿼리는 메인쿼리에 종속되므로 단독으로 실행할 수 없다.

<br/>
<br/>
<br/>
<br/>
<br/>

### 참조
- 친절한 SQL 튜닝
